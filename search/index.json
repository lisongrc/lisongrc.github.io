[{"content":"如何确认目前Mac 电脑所用的SSD 寿命和健康度还剩多久呢？\n安装工具smartmontools brew install smartmontools 通过diskutil list指令来查询SSD硬盘设备标签代码 或者打开磁盘管理工具查看：\n执行命令 注意命令里面的disk1s1换成你自己的标识符。\nsmartctl -a disk1s1 至于SMART 工具里面显示的数据可对照底下说明：\n严重警告（Critical Warning）：会显示控制器状态警告讯息，如果都显示0x00 就表示没事 温度（Temperature）：会显示当前SSD 温度资讯 可用备用空间（Available Spare）：SSD 剩余空间百分比 可用备用临界值（Available Spare Threshold）：临界值全由厂商定义 寿命百分比（Percentage Used）：目前SSD 寿命百分比数值，具体取决于实际设备使用情况和厂商对设备寿命的预测。 资料读取（Data Units Read）：记录电脑从SSD读取512字节数据单元的总量，每1000个单元记录一次，即这项Raw数据1的值等于500KB。 资料写入（Data Units Read）：如上，就是写入总量。 主机读取命令（Host Read Commands）：主控收到的读取命令数量。 主机写入命令（Host Write Commands）：主控收到的写入命令数量。 控制器忙碌时间（Controller Busy Time）：主控忙于I/O命令的时间。 意外关机（Unsafe Shutdowns）：纪录不正常断电次数 媒体和资料完整性错误（Media and Data Integrity Errors）：主控检测得到的未恢复的数据完整性错误次数。 错误资料纪录（Number of Error Information Log Entries）：主控总共收到的错误信息日志数量。 通常我们主要确认「寿命百分比（Percentage Used）」这项数值就好，通常达到90%以上就要额外注意。\n","date":"2022-02-13T18:31:00Z","permalink":"https://lisongrc.github.io/p/2022023fc8d0f9/","title":"查看Mac SSD寿命与健康度"},{"content":" Homebrew可以方便地安装你需要的包或者app。\n一、安装 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 二、使用 搜索包 brew search wget 安装包 brew install wget 卸载包 brew uninstall wget 显示包信息 brew info wget 查看已安装的包 brew list brew list --cask 更新Homebew brew update 列出可以升级的包 brew outdated\t升级所有已安装的包 brew upgrade --force --greedy 升级某些包 brew upgrade wget 清理缓存 brew cleanup 三、卸载 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)\u0026#34; 四、homebrew-bundle homebrew-bundle可以帮助我们备份已安装的包和app们，这样我们在重装系统或者换电脑后可以一键恢复安装，节省时间。\n备份 下面这条命令意思是备份我的安装列表，\u0026ndash;describe代表会加上包的描述，\u0026ndash;force代表覆盖已有的文件，\u0026ndash;file指定输出文件，这里我指定iCloud云盘里的Brewfile文件，因为这样系统就会自动同步这个文件了哈哈。\nbrew bundle dump --describe --force --all --file=\u0026#34;~/Library/Mobile Documents/com~apple~CloudDocs/Brewfile\u0026#34; 生成的文件大概是这样：\ntap \u0026#34;homebrew/bundle\u0026#34; tap \u0026#34;homebrew/cask\u0026#34; tap \u0026#34;homebrew/core\u0026#34; # Mac App Store command-line interface brew \u0026#34;mas\u0026#34; # Open source relational database management system brew \u0026#34;mysql\u0026#34; # Tool to list all active shortcuts of the current application cask \u0026#34;cheatsheet\u0026#34; # Free and open-source media player cask \u0026#34;iina\u0026#34; mas \u0026#34;Developer\u0026#34;, id: 640199958 mas \u0026#34;Hidden Bar\u0026#34;, id: 1452453066 mas \u0026#34;The Unarchiver\u0026#34;, id: 425424353 mas \u0026#34;Xcode\u0026#34;, id: 497799835 恢复安装 因为iCloud备份了Brewfile文件，我们可以一键恢复安装：\nbrew install mas brew bundle install --file=\u0026#34;~/Library/Mobile Documents/com~apple~CloudDocs/Brewfile\u0026#34; ","date":"2021-04-25T23:18:12Z","permalink":"https://lisongrc.github.io/p/2021043dc4d0c2/","title":"Homebrew的使用"},{"content":" 本文总结一些Chrome上好用的插件们。\n扩展管理器（Extension Manager） 一键管理所有扩展，快速开启/禁用、批量闪电管理，智能排序，右键卸载、锁定、选项配置，角标提醒，大小布局随心配。快捷、简单、安全。\nAdGuard AdGuard 广告拦截器可有效的拦截所有网页上的所有类型的广告，甚至是在 Facebook、Youtube 以及其他万千网站上的广告！\nTampermonkey Tampermonkey用于在网站上运行所谓的用户脚本（有时也称为Greasemonkey脚本）。\nAwesome Screenshot 截图和录屏2合1的工具，支持截取整个页面，快速分享屏幕。\nJSON-handle 对JSON格式的内容进行浏览和编辑，以树形图样式展现JSON文档，并可实时编辑。\n恢复关闭的标签 只要点击弹窗可让您轻而易举的撤销关闭的标签！\n工具喵 工具喵（开发常用工具）：Unix时间戳、URL编码/解码、IP地址查询、MD5加密、BASE64编码/解码、随机字符串\nSpeedtest by Ookla 测试网络表现和网站加载速度\nImagus 鼠标指针悬停在链接或缩略图上时直接在当前页面的弹出视图上显示这些图片、HTML5 视频/音频和内容专辑。\nImage Downloader 显示和下载一个网页上的图片们\nGIPHY for Chrome 搜索gif图片\nOctotree - GitHub code tree 更方便地浏览Github的代码\nNative HLS Playback 播放m3u8视频\n购物党自动比价工具 浏览商品页面时，自动查询180天历史价格、比较同款商品的全网最低价、提示促销和隐藏优惠券、一旦降价还能通过微信提醒你，海淘、二手房和Steam游戏也能比价！\n掘金 在新标签页展示聚合内容，包含前端、Android、iOS、后端、产品、设计六大频道，每个频道内都有一到多个内容源。\n","date":"2021-04-24T10:15:05Z","permalink":"https://lisongrc.github.io/p/2021045dc07d30/","title":"Chrome好用的插件，持续更新"},{"content":" 本文总结一些有用的网站们。\nprocesson ：免费在线作图、实时协作，支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等 lottiefiles ：在线看lottie效果 regex101 ：在线正则匹配 m3u8 downloader ：m3u8 视频在线提取工具 DownGit ：下载github项目上的文部分文件 msdn.itellyou ：下载Windows系统 Pro Git 中文版 ：讲解Git的使用 swift ：Swift官方网站 cnswift ：Swift 编程语言 – 可能是最用心的翻译了吧 swiftify ：OC转Swift system-status ：查看苹果服务状态 IPIP.NET ：一些网络工具 IP.cn ：全国 DNS 服务器 IP 地址汇总 onevcat ：喵神的博客 美团技术团队 ：美团的技术博客 Font Awesome ：图标字体 NexT ：NexT 使用文档 leetcode ：练习算法 quicktype ： json解析为多种语言 腾讯开源项目 ","date":"2021-04-17T20:46:53Z","permalink":"https://lisongrc.github.io/p/2021044decb28c/","title":"一些网站们，持续更新"},{"content":" 之前总结了 Mac上好用的软件推荐，本文总结一下iOS开发常用的效率工具，所谓工欲善其事，必先利其器，好的工具会使我们的生活更美好。\nimageoptim 压缩图片，减少包体积。\nLSUnusedResources 找到项目里没用的图片，可以批量删除（但还是建议确认无误后再删）。\nCATClearProjectTool 找到项目里没用的类文件，可以设置过滤条件一键删除（同样还是建议先确认后再删）。\nNWPusher 模拟推送，方便调试推送相关的东西。\nDeveloper 苹果官方应用，可以看历年的WWDC视频。\nBuildTimeAnalyzer 对Swift文件的编译时间进行分解，方便后续优化。\nOpenSim 一个iOS开发查看模拟器沙盒里面文件的应用，很方便。 Linguan 一款Mac/iOS应用汉化工具，它可以帮助你对任何软件进行语言本地化翻译，操作比较简单，你只需要选择目标程序的.project，然后Linguan里就回加载出来然后进行编辑。 swiftify OC代码转Swift\nappsight 查看某款iOS APP使用了哪些SDK和服务\n","date":"2021-04-17T18:29:22Z","permalink":"https://lisongrc.github.io/p/202104d0a1724/","title":"iOS开发常用的效率工具，持续更新"},{"content":" 本文总结一下Mac上的软件们，不仅限于开发相关的软件。所谓工欲善其事，必先利其器，好的软件会使我们的生活更美好。\n安装包打不开的问题 有时候我们下载下来的安装包双击后打不开，提示来自身份不明的开发者或者提示已损坏，解决办法如下：\n在终端输入sudo spctl --master-disable回车，输入密码回车，然后进入系统偏好设置-安全性与隐私-通用，然后点击左下角的锁，输入密码开锁，然后选择任何来源就可以了。系统会记录这个选择，如果30天没有安装过其它来源的软件，系统会还原到默认设置。\n你也可以输入sudo spctl --master-enable再去隐藏这个选项。\n下面是一些推荐软件：\nHomebrew Homebrew可以方便地安装你需要的包或者app。\nCheatSheet 长按command键可以查看当前应用的快捷键，很方便。 Shuttle 支持快捷执行一些常用的命令。\nHidden Bar 一款实用的菜单栏管理工具，可以隐藏一些不常用的图标。\nWeiboX 几乎是全功能微博，用它看大图和看视频比手机爽多了有木有。 SwitchHosts 管理hosts文件的工具。\nDownie Downie 是 macOS 上的知名视频下载工具，支持全球超过 1000 个在线视频网站的下载\nSnip 腾讯出品的简单高效的截图工具，可以滚屏截网页全屏，也可以截取完简单编辑图片，例如加箭头、写文字等等。 XMind 思维导图工具，在易用性和灵活性方面引人瞩目。将脑中的源源不断涌现的想法完美的展现出来，其思维导图与其他导图图表等更是简单易用，吸引着人们的眼球。 imageoptim 优化图片体积的应用，直接把图片拖进去就可以了。 SourceTree 一个Git客户端，图形化的界面很好用。 Foxmail 邮件客户端，添加账户后使用非常方便，很多人都在用他收发公司的企业邮件。 The Unarchiver 一款解压缩软件。 iStat Menus 系统与硬件监控软件，可以在Finder菜单栏显示CPU使用率、内存使用、硬盘读写速度、网络上传下载速率使用情况、温度传感器温度等数据。 刚开始安装各个功能是分开展示在菜单栏上的，看起来很乱，可以设置为聚合下拉显示。 Sublime Text Sublime Text 是一个非常好用的代码编辑器。拥有漂亮的用户界面和非凡的功能，例如迷你地图，代码段等等。可以自定义快捷键，菜单和工具栏，还支持插件扩展机制。\nxScope 一款设计开发辅助应用，包含多个实用的小工具，如度量距离，角度的标尺，放大镜，精确垂直，水平标记辅助线等等，都是设计时非常实用的辅助工具。 OmniGraffle 可以用来绘制图表，流程图，组织结构图以及插图。 Sketch 强大的移动应用矢量绘图设计工具。使用简单，学习曲线低，能够大大节省设计师的时间和工作量，非常适合进行网站设计、移动应用设计、图标设计等。 MindNode 一款思维导图软件，能够让我们快速的创建出美观的思维导图，并且具有iPhone和iPad客户端，支持 iCloud Drive 和 HandsOff 协作功能。 1Password 1Password 可以记住你所有的密码并保障他们的安全。你只需要记住主密码即可。 Tickeys 一款能够在打字时模拟机械键盘音效的应用，此外还能模拟冒泡、打字机、剑气、爆裂鼓手的音效。 Shazam 一款音乐识别软件。在打开过程中会接收周围声音，一旦侦测到歌曲，就弹出推送通知。点击顶部菜单栏的 Shazam 图标可以开/关接收功能，或者查看所有识别出的歌曲。点某一首歌曲的可以跳到详情网页，查看专辑、歌手、同专辑音乐等详细信息。 Bartender 一款非常实用的菜单栏管理小助手。用Bartender来对杂乱的菜单栏进行管理是再好不过的了。 Mark Man 下载地址：http://www.getmarkman.com/ 。 高效的设计稿标注、测量工具。 PaintCode 简单的矢量图形绘图应用程序，能画出美丽的控件，图标或其他UI界面元素并直接生成适用于iOS或者OS X或者Java或者Web的代码。 Reflector iOS录屏、AirPlay镜像工具。 Charles Mac上的抓包工具 Navicat Premium 强大的数据库管理工具 GitNote 一款基于 Git 的云笔记工具，支持 Windows、macOS、Linux，使用 Git 仓库作为数据保存，如 GitHub、GitLab 等，内置 git 支持，依托 Git 仓库的特性，拥有历史版本、私密笔记、无限空间等特点。\n支持MarkDown、思维导图、流程图等等。\nGoogle Drive File Stream 谷歌硬盘同步工具，可根据不同的文件夹设置在线还是离线使用。\nTypora Typora 是一款支持实时预览的 Markdown 文本编辑器\nmarktext 一款开源的编写Markdown的工具。\n","date":"2021-04-16T14:08:24Z","permalink":"https://lisongrc.github.io/p/202104e9bf20fb/","title":"Mac上好用的软件推荐，持续更新"},{"content":" 本文记录一些我使用Linux时遇到的一些东西，因为我主要用Debian，所以这些基本上都是在Debian环境下的。\n启用root帐户登录ssh 先用其它帐户登录ssh，然后su到root输入密码登录，然后修改 /etc/ssh/sshd_config ：\n#PermitRootLogin prohibit-password PermitRootLogin yes 然后重启ssh服务，就可以root用户登录ssh了：\n/etc/init.d/ssh restart 设置或者修改时区 检查当前时区：\ntimedatectl 修改时区：\nsudo timedatectl set-timezone your_time_zone 例如修改为Shanghai:\nsudo timedatectl set-timezone Asia/Shanghai 至于具体有哪些时区可用呢，可以用 timedatectl list-timezones 命令查看或者去 /usr/share/zoneinfo 目录里面看。\n自定义开机启动项 首先，进入 /etc/init.d 目录中：\ncd /etc/init.d/ 你会发现里面已经有一些启动项了。然后我们创建一个自己的：\nvim MyTest 在里面输入以下内容：\n#!/bin/sh ### BEGIN INIT INFO # Provides: MyTest # Required-Start: $network $remote_fs $local_fs # Required-Stop: $network $remote_fs $local_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: MyTest # Description: MyTest ### END INIT INFO echo \u0026#34;Hello World !\u0026#34; \u0026gt;\u0026gt; ~/mytest.txt exit 0 这个是一个大概的模板，其中 echo \u0026quot;Hello World !\u0026quot; \u0026gt;\u0026gt; ~/mytest.txt 部分就是系统启动时要执行的命令，意思在指定文件里写入一句话。你可以在根据自己的需要写一些命令。\n写完保存之后，给文件加上可执行的属性：\nchmod +x MyTest 然后，将脚本加入开机启动项中：\nupdate-rc.d MyTest defaults 如果需要删除这个开机启动项，则使用命令：\nupdate-rc.d -f MyTest remove ","date":"2021-03-27T23:05:38Z","permalink":"https://lisongrc.github.io/p/20210391370673/","title":"Linux使用相关的一些东西"},{"content":"nmap 和 masscan 都是出名的端口扫描工具，本文讲解一下大概怎么使用。\nnmap nmap是一个老牌的互联网端口扫描器。\n安装 brew install nmap 使用 一个最简单的例子，扫描ip 10.0.0.0的一些已知协议的端口：\nnmap 10.0.0.0 不判断主机是否在线：\nnmap 10.0.0.0 -Pn 扫描多个ip:\nnmap 10.0.0.0/24 -Pn nmap 10.0.1-255.1-255 -Pn 扫描指定端口：\nnmap 10.0.0.0 -Pn -p20-200,7777,8888 只显示开放端口：\nnmap 10.0.0.0 -Pn -p0-65525 --open 从文件读取要扫描的ip：\nnmap -Pn --open -iL ip.txt 将结果输出到文件：\nnmap 10.0.0.0/8 -Pn --open -oG result.txt masscan masscan号称是最快的互联网端口扫描器，可以在六分钟内扫遍互联网。也支持nmap的一些参数设置。\n安装 brew install masscan 使用 一个最简单的例子，扫描ip 10.0.0.0的80端口:\nmasscan -p80 10.0.0.0 扫描ip段的多端口：\nmasscan -p80 10.0.0.0/8 扫描多端口：\nmasscan 10.0.0.0/8 -p0-65535 设置扫描速度：\nmasscan 10.0.0.0/8 -p0-65535 --max-rate 10000 将结果输出到文件：\nmasscan 10.0.0.0/8 -p0-65535 --max-rate 10000 -oJ result.json masscan 10.0.0.0/8 -p0-65535 --max-rate 10000 -oL result.txt 从文件读取要扫描的ip：\nmasscan -p0-65535 --max-rate 10000 -iL ip.txt -oJ result.json 使用配置文件：\n# myscan.conf rate = 100000.00 output-format = xml output-status = all output-filename = scan.xml ports = 0-65535 range = 0.0.0.0-255.255.255.255 excludefile = exclude.txt masscan -c myscan.conf 更过高级和详细的用法可以去看官方文档。\n","date":"2021-03-25T22:53:10Z","permalink":"https://lisongrc.github.io/p/202103f85f9aaa/","title":"nmap和masscan的使用"},{"content":"这片文章总结一些好用的Xcode快捷键，可以提高开发的效率。\n对应键位 ⌘：command\n⌥：option\n⌃：control\n⇧：shift\nXcode常用快捷键 快捷键 含义 ⌘ + [ ] 左右移动代码 ⌘ + ⌥ + [ ] 上下移动代码 ⌃ + D 删除光标右侧字符 ⌃ + K 删除本行光标后面所有字符 ⌃ + \\ 依次回到编辑过的地方 ⌘ + ⌃ + ↑↓ .h与.m之间切换 ⌘ + ⌃ + E 批量高亮并修改一个变量 ⌘ + ⌃ + J 跳到类或者变量定义的地方 ⌘ + L 快速跳转到特定行 ⌘ + ⇧ + j 快速定位当前文件在项目文件中的位置 ⌘ + ⇧ + O 快速搜索打开文件和类 CheatSheet 大家可以安装CheatSheet这个app，然后长按⌘键就会出现当前使用的app的快捷键。这样如果忘了某个快捷键可以快速查找。\nbrew install cheatsheet ","date":"2021-03-06T21:58:55Z","permalink":"https://lisongrc.github.io/p/2021034535997/","title":"Xcode好用的快捷键"},{"content":"Hexo默认的主题是 landscape，由于它的功能和样式我都不太喜欢，所以决定换个样式玩玩。\n找Hexo主题的话可以去Github搜索 hexo-theme，然后都点进去看看，挑一个自己喜欢的样式；一般主题下都有使用教程。\n这里以 hexo-theme-next 为例。\n安装 NexT 执行以下命令会把 NexT 主题clone到博客的 themes/next 目录下。\ncd hexo git clone https://github.com/theme-next/hexo-theme-next themes/next 然后将Hexo根目录下的 _config.yml 里面的 theme 设置成 next：\ntheme: next 然后 hexo s 启动服务器，刷新自己的博客发现样式已经变了。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务\n选择 Scheme NexT可以通过Scheme提供多种不同的外观，Scheme 的切换通过更改 themes/next 目录下的 _config.yml 文件，搜索 scheme 关键字，可以看到有四种，你可以都试一试，选择自己喜欢的。\n# Schemes scheme: Muse #scheme: Mist #scheme: Pisces #scheme: Gemini 详细设置 这个主题的一些详细设置，比如添加菜单、添加分类什么的，可以看 官方文档 ，讲的很详细。\n","date":"2021-03-02T12:44:06Z","permalink":"https://lisongrc.github.io/p/202103259164c9/","title":"Hexo切换NexT主题"},{"content":"你可能觉得 username.gitlab.io 和 username.github.io 这样的域名有点长，或者说不好看，可以设置用自己的域名来访问自己的博客，接下来我们一个一个说。\nGitLab Pages 在仓库的 Settings -\u0026gt; Pages 里面，点击 New Domain 出现这个界面：\n输入自己的域名然后点击 Create 出现这个界面：\n可以看到，它让我们加一个 CNAME 记录将域名解析到gitlab.io上，然后需要设置一个 TXT 记录为那一长串字符。比如在 DNSPod 里是这样设置的：\nGitLab还会用 Let's Encrypt 为我们自动生成证书，这样就可以启用HTTPS了。\n配置完成后稍等一会，就可以用自己的域名访问GitLab博客了。\nGitHub Pages 在仓库的 GitHub Pages -\u0026gt; Custom domain 里输入自己的域名，点击 Save ；然后勾选上 Enforce HTTPS 启用HTTPS（可能需要等一会才可以勾选）。\n然后需要加一个 CNAME 记录将域名解析到github.io上，比如在 DNSPod 里是这样设置的：\n配置完成后稍等一会，就可以用自己的域名访问GitHub博客了。\n为了防止以后每次 hexo d 会清空 CNAME 文件导致GitHub Pages域名解绑，需要在本地博客的 source目录下创建一个 CNAME 文件，文件内容为你的域名，例如：\nblog.lisong.com ","date":"2021-03-02T01:12:48Z","permalink":"https://lisongrc.github.io/p/2021039700ba13/","title":"给博客绑定域名并启用HTTPS"},{"content":"前言 之前在一些平台写过一段时间博客，后来由于各种原因就慢慢荒废了；最近心血来潮想要把一些东西记录下来，所以决定搭建一个博客玩玩。\nHexo介绍 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\nHexo安装 我用的Mac系统，所以直接homebrew安装:\nbrew install hexo Hexo建站 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\nhexo init \u0026lt;folder\u0026gt; 新建完成后，文件夹的目录大致如下:\n. ├── _config.landscape.yml ├── _config.yml ├── package.json ├── scaffolds │ ├── draft.md │ ├── page.md │ └── post.md ├── source │ └── _posts │ └── hello-world.md ├── themes └── yarn.lock _config.yml 是一些配置信息，你可以在此配置大部分的参数。 package.json 是依赖的一些包。 scaffolds 是模版文件夹。 source 是存放用户资源的地方，那个 hello-world.md 就是默认生成的一篇文章。 themes 是主题文件夹，你可以在里面配置自己喜欢的主题。\nHexo指令 hexo g 生成静态文件，在 public 目录下。\nhexo s 启动本地服务器。打开 http://localhost:4000/ 就可以看到我们的博客啦。\nhexo new \u0026#34;article title\u0026#34; 新建一篇文章。在 source\\_posts 目录下就多了一个.md文件。\n将博客部署到GitLab Pages 在Gitlab创建一个repository，名字为username.gitlab.io，username就是你的Gitlab用户名。\n在博客目录下生成git，并配置远端仓库，然后提交代码。\ngit init git remote add origin git@gitlab.com:username/username.gitlab.io.git 在你的博客目录下新建一个 .gitlab-ci.yml 文件内容如下：\nimage: node:10-alpine # use nodejs v10 LTS cache: paths: - node_modules/ before_script: - ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime - npm install hexo-cli -g - npm install pages: script: - hexo generate artifacts: paths: - public only: - master GitLab CI 会自动开始运行，构建成功以后稍等几分钟，打开 https://username.gitlab.io 应该就能看到自己的博客了。\n如果想隐藏博客源码，又不想影响博客的正常访问，可以在仓库的 Settings -\u0026gt; General -\u0026gt; Visibility, project features, permissions 里面将仓库权限设置为 private，然后把下面的 Pages 选项改为 Everyone。\n将博客部署到GitHub Pages 在这里我将继续用Gitlab的仓库存储博客源码，将生成的静态博客部署到Github。\n在GitHub创建一个repository，名字为username.github.io，username就是你的GitHub用户名。如果是免费账户的话，repository要是public的，不然不能启用GitHub Pages。\n安装 hexo-deployer-git :\nnpm install hexo-deployer-git --save 修改 _config.yml 里面的 deploy 配置改为\ndeploy: type: git repo: git@github.com:username/username.github.io.git branch: main 然后运行以下命令，就会把生成的 public 文件夹里的东西都push上去。\nhexo clean \u0026amp;\u0026amp; hexo d 在Github上，打开项目的 Settings ，找到 GitHub Pages 设置，如果没有开启的话先开启，然后 Branch选择 main，folder 选择 /(root)。勾选上 Enforce HTTPS 启用HTTPS。\n都弄好之后，稍等片刻，打开 https://username.github.io 就能看到自己的博客了。\n","date":"2021-02-28T22:37:01Z","permalink":"https://lisongrc.github.io/p/202102d52b09e8/","title":"Hexo搭建个人博客并部署到Gitlab和GitHub"},{"content":"一、LLDB 什么是LLDB LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。Xcode中绑定了LLDB，调试器允许你在程序运行时暂停它，可以查看变量的值，执行自定的指令。\n在程序里你需要的地方设置断点。当断点断住的时候你就能看到我们进入LLDB调试器了，下面这个界面对于iOS开发者来说应该不陌生了：\n几个常用命令 help help命令可以查看LLDB的所有命令：\n它也可以查看某一条命令的使用帮助，比如：help print会打印print命令的使用帮助：\nprint print命令的简化方式有p，po等等。p输出的是基本类型，po输出的Objective-C对象，调试器会输出这个 object 的 description。\nexpression命令 expression的简写就是e。可以用来执行一条语句。例如：\nLLDB还有很多命令可以使用，具体用法大家可以看文档\n二、Chisel 什么是Chisel Chisel是facebook开源的一个LLDB命令的集合，它里面简化和扩展了LLDB的命令。使用它会更方便的调试我们的程序。在它的GitHub上有详细的安装方式，这里就不赘述了。\n常用命令： 他的所有命令在它的wiki上都列出来了，这里我挑几个示范一下。\npviews 这个命令可以按层级递归打印指定view的所有subView，相当于 UIView 的私有辅助方法 [view recursiveDescription]。如果不指定view的话就是默认window：\npvc 这个命令递归打印出viewController的层级，相当于 UIViewController 的一个私有辅助方法 [UIViewController _printHierarchy] ：\nvisualize 它可以使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 我们其实可以用这个功能来截图或者查看一个view的具体内容：\n(lldb) visualize 0x7feb5cf18210 (lldb) visualize self.view mask/unmask mask用来在view或者layer上覆盖一个半透明的矩形， unmask解除。当我们想找一个view的时候可以使用。\n(lldb) mask self.imageView (lldb) unmask 0x7f8732e037b0 border/unborder border可以给view或者layer添加边框，unborder解除。当我们想找一个view的时候可以使用。\n(lldb) border self.imageView (lldb) unborder 0x7f8732e037b0 show/hide 显示隐藏一个view或者layer。\n(lldb) hide self.imageView (lldb) show self.imageView caflush 这个命令用来刷新UI，当我们改变了UI的时候，不用重新启动，使用caflush刷新UI就行。\npresponder 打印响应者链：\npclass 打印指定对象的class的继承关系：\npjson 打印一个字典或者数组的json样式。\nslowanim/unslowanim 减慢动画的效果，检查一个动画哪里有问题时可以使用。\npdocspath 打印App的Documents路径：\nfv \u0026amp; fvc 这两个命令是用来搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。\ntaplog 点击某个view时，程序会暂停，会打印被点击的view。\npcurl 把一个NSURLRequest (HTTP)打印成curl命令。\n更多的命令大家可以去官方文档看。\n","date":"2019-03-10T20:05:31Z","permalink":"https://lisongrc.github.io/p/2019035053e96d/","title":"iOSer都要知道的LLDB介绍与Chisel进阶"},{"content":"哼哼想不到吧，我又回来啦！好久没写文章了，以后尽量多写写吧。最近看到有人问@功能的需求，就大概写了写，先看看实现效果： 这个功能的具体要求如下：\n1、一个@是由一个@字符和一个空格 字符包起来的。 2、支持手写输入，只要符合就高亮显示。 3、支持从列表选择，选择后插入光标所在位置并高亮。 4、光标不能出现在一个@词中间，点击中间后自动移动到@词后面，长按滑动光标时也要越过@词。但是当用户长按选择文本时可以。 5、当光标正好在一个@词后面时，按删除键@词要整体删除。\n先附上本文demo，算下来代码也没有多少，还算简洁，大家一看就懂。其中包括的功能：\n1、输入框@编辑和选择功能，也就是上面那些需求。 2、输入框随着文字多少改变高度，并根据键盘随动。 3、发布后显示在列表上，并将符合的@高亮显示。 4、列表上的cell根据文字自动计算高度。 5、点击高亮词后可以捕获到事件，自己实现跳转就可以。\n好了，下面大概讲解一下，有不明白的地方可以下载demo具体看看。\n用到的第三方 1、HPGrowingTextView，用来实现输入框根据文字改变高度。使用和UITextView类似，代理也和UITextView差不多： 2、MLLabel，用来高亮显示label文本中的某些文字，支持自动识别一些常见的，也可以自定义规则。支持链接色和点击色等等一些配置。点击回调里面自己实现跳转就可以。\n集成这些第三方用的是cocoapods，关于cocoapods的教程可以看我的这篇文章;\n具体实现的一些细节 1、检验文本中所有的@词 用的是系统的NSRegularExpression类，不熟悉的大家可以去查一下，这里就不细讲了：\n- (NSArray\u0026lt;NSTextCheckingResult *\u0026gt; *)findAllAt { // 找到文本中所有的@ NSString *string = self.growingTextView.text; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:kATRegular options:NSRegularExpressionCaseInsensitive error:nil]; NSArray *matches = [regex matchesInString:string options:NSMatchingReportProgress range:NSMakeRange(0, [string length])]; return matches; } 2、输入框根据输入文字多少自动改变高度 在HPGrowingTextView的代理里面实现：\n- (void)growingTextView:(HPGrowingTextView *)growingTextView willChangeHeight:(float)height { self.commentViewHeight.constant = height + 14; } 3、输入框中的文字要随着文字改变实时将@词高亮 - (void)growingTextViewDidChange:(HPGrowingTextView *)growingTextView { UITextRange *selectedRange = growingTextView.internalTextView.markedTextRange; NSString *newText = [growingTextView.internalTextView textInRange:selectedRange]; if (newText.length \u0026lt; 1) { // 高亮输入框中的@ UITextView *textView = self.growingTextView.internalTextView; NSRange range = textView.selectedRange; NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:textView.text]; [string addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:NSMakeRange(0, string.string.length)]; NSArray *matches = [self findAllAt]; for (NSTextCheckingResult *match in matches) { [string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(match.range.location, match.range.length - 1)]; } textView.attributedText = string; textView.selectedRange = range; } } 首先判断是不是正在输入拼音，不是的话我们才应该处理。然后就是用正则找到所有的@词，用NSMutableAttributedString的方法加上高亮色，然后把最终的attributedString赋值给TextView，并将光标的位置复原为替换文本之前的状态。\n4、删除时@词要整体删除 - (BOOL)growingTextView:(HPGrowingTextView *)growingTextView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text { if ([text isEqualToString:@\u0026#34;\u0026#34;]) { NSRange selectRange = growingTextView.selectedRange; if (selectRange.length \u0026gt; 0) { //用户长按选择文本时不处理 return YES; } // 判断删除的是一个@中间的字符就整体删除 NSMutableString *string = [NSMutableString stringWithString:growingTextView.text]; NSArray *matches = [self findAllAt]; BOOL inAt = NO; NSInteger index = range.location; for (NSTextCheckingResult *match in matches) { NSRange newRange = NSMakeRange(match.range.location + 1, match.range.length - 1); if (NSLocationInRange(range.location, newRange)) { inAt = YES; index = match.range.location; [string replaceCharactersInRange:match.range withString:@\u0026#34;\u0026#34;]; break; } } if (inAt) { growingTextView.text = string; growingTextView.selectedRange = NSMakeRange(index, 0); return NO; } } //判断是回车键就发送出去 if ([text isEqualToString:@\u0026#34;\\n\u0026#34;]) { [self.comments addObject:growingTextView.text]; self.growingTextView.text = @\u0026#34;\u0026#34;; [self.growingTextView resignFirstResponder]; [self.tableView reloadData]; return NO; } return YES; } 首先判断替换词是空字符串就代表是删除操作，然后找出输入框文字中所有的@词，判断要删除的字符是否在任意一个@词中间，如果在就把输入框文字中这个@词整体删除，然后重新赋值给TextView，并纠正光标的位置。但是要判断用户在长按选择文本时不处理。\n5、光标不能点击落在一个@词中间： - (void)growingTextViewDidChangeSelection:(HPGrowingTextView *)growingTextView { // 光标不能点落在@词中间 NSRange range = growingTextView.selectedRange; if (range.length \u0026gt; 0) { // 选择文本时可以 return; } NSArray *matches = [self findAllAt]; for (NSTextCheckingResult *match in matches) { NSRange newRange = NSMakeRange(match.range.location + 1, match.range.length - 1); if (NSLocationInRange(range.location, newRange)) { growingTextView.internalTextView.selectedRange = NSMakeRange(match.range.location + match.range.length, 0); break; } } } 其实就是判断光标改变位置后是否在@词中间，如果在就把光标强制移动到@词后面。但是当用户长按选择文本时可以。\n6、从列表中选择人去@他 - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { // 去选择@的人 [self.growingTextView.internalTextView unmarkText]; NSInteger index = self.growingTextView.text.length; if (self.growingTextView.isFirstResponder) { index = self.growingTextView.selectedRange.location + self.growingTextView.selectedRange.length; [self.growingTextView resignFirstResponder]; } SelectUserController *atVC = segue.destinationViewController; atVC.selectBlock = ^(NSString *name) { UITextView *textView = self.growingTextView.internalTextView; NSString *insertString = [NSString stringWithFormat:kATFormat,name]; NSMutableString *string = [NSMutableString stringWithString:textView.text]; [string insertString:insertString atIndex:index]; self.growingTextView.text = string; [self.growingTextView becomeFirstResponder]; textView.selectedRange = NSMakeRange(index + insertString.length, 0); }; } 其实就是选择后将@词插入到光标位置，并将光标纠正到@词后面。\n7、评论列表cell上的@高亮并可点击。使用MLLabel实现起来还是比较简单的： - (void)setComment:(NSString *)comment { _comment = comment; self.titleLabel.text = comment; // 高亮@ NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:kATRegular options:NSRegularExpressionCaseInsensitive error:nil]; [regex enumerateMatchesInString:comment options:NSMatchingReportProgress range:NSMakeRange(0, comment.length) usingBlock:^(NSTextCheckingResult * _Nullable result, NSMatchingFlags flags, BOOL * _Nonnull stop) { [self.titleLabel addLinkWithType:MLLinkTypeUserHandle value:comment range:result.range]; }]; } self.titleLabel.didClickLinkBlock = ^(MLLink *link, NSString *linkText, MLLinkLabel *label) { NSLog(@\u0026#34;点击了%@\u0026#34;,linkText); }; 8、cell高度自动计算，系统自己支持，不了解的可以看我的这篇文章。 好了，大概就是这么些东西，是不是很简单呢，如果还有不明白的地方就下载本文demo仔细看看吧。\n","date":"2018-05-26T23:31:55Z","permalink":"https://lisongrc.github.io/p/201805784ea6a5/","title":"iOS中@功能的完整实现"},{"content":"Objective-C 是一个动态语言，它需要一个运行时系统来动态的创建类和对象、进行消息传递和转发。关于Runtime的知识大家可以参看Apple开源的Runtime代码 和Rumtime编程指南 。\n本文总结一些其常用的方法。\n一、新建测试Demo 我们先创建一个测试Demo如下图，其中TestClass是一个测试类，TestClass+Category是它的一个分类，NSObject+Runtime封装了一些Runtime的方法。大家可以在这里下载Demo。\n下面是几个类的主要部分：\n二、Runtime的封装 接下来我们就来看看NSObject+Runtime中的内容，其对Runtime常用的方法进行了简单的封装：\n别着急，我们一个一个看。\n1、获取成员变量 下面这个方法就是获取类的成员变量列表，其中包括属性生成的成员变量。我们可以用ivar_getTypeEncoding()来获取成员变量的类型，用ivar_getName()来获取成员变量的名称：\n+ (NSArray *)fetchIvarList { unsigned int count = 0; Ivar *ivarList = class_copyIvarList(self, \u0026amp;count); NSMutableArray *mutableList = [NSMutableArray arrayWithCapacity:count]; for (unsigned int i = 0; i \u0026lt; count; i++ ) { NSMutableDictionary *dic = [NSMutableDictionary dictionaryWithCapacity:2]; const char *ivarName = ivar_getName(ivarList[i]); const char *ivarType = ivar_getTypeEncoding(ivarList[i]); dic[@\u0026#34;type\u0026#34;] = [NSString stringWithUTF8String: ivarType]; dic[@\u0026#34;ivarName\u0026#34;] = [NSString stringWithUTF8String: ivarName]; [mutableList addObject:dic]; } free(ivarList); return [NSArray arrayWithArray:mutableList]; } 使用[TestClass fetchIvarList]方法获取TestClass类的成员变量结果：\n2、获取属性列表 下面这个方法获取的是属性列表，包括私有和公有属性，也包括分类中的属性：\n+ (NSArray *)fetchPropertyList { unsigned int count = 0; objc_property_t *propertyList = class_copyPropertyList(self, \u0026amp;count); NSMutableArray *mutableList = [NSMutableArray arrayWithCapacity:count]; for (unsigned int i = 0; i \u0026lt; count; i++) { const char *propertyName = property_getName(propertyList[i]); [mutableList addObject:[NSString stringWithUTF8String:propertyName]]; } free(propertyList); return [NSArray arrayWithArray:mutableList]; } 使用[TestClass fetchPropertyList]获取TestClass的属性列表结果:\n3、获取实例方法 下面这个方法就是获取类的实例方法列表，包括getter, setter, 分类中的方法等：\n+ (NSArray *)fetchInstanceMethodList { unsigned int count = 0; Method *methodList = class_copyMethodList(self, \u0026amp;count); NSMutableArray *mutableList = [NSMutableArray arrayWithCapacity:count]; for (unsigned int i = 0; i \u0026lt; count; i++) { Method method = methodList[i]; SEL methodName = method_getName(method); [mutableList addObject:NSStringFromSelector(methodName)]; } free(methodList); return [NSArray arrayWithArray:mutableList]; } 使用[TestClass fetchInstanceMethodList]获取TestClass的实例方法列表的结果：\n4、获取类方法列表 下方这个方法就是获取类的类方法列表：\n+ (NSArray *)fetchClassMethodList { unsigned int count = 0; Method *methodList = class_copyMethodList(object_getClass(self), \u0026amp;count); NSMutableArray *mutableList = [NSMutableArray arrayWithCapacity:count]; for (unsigned int i = 0; i \u0026lt; count; i++) { Method method = methodList[i]; SEL methodName = method_getName(method); [mutableList addObject:NSStringFromSelector(methodName)]; } free(methodList); return [NSArray arrayWithArray:mutableList]; } 使用[TestClass fetchClassMethodList]获取TestClass的类方法列表的结果：\n5、获取协议列表 下面是获取类所遵循协议列表的方法：\n+ (NSArray *)fetchProtocolList { unsigned int count = 0; __unsafe_unretained Protocol **protocolList = class_copyProtocolList(self, \u0026amp;count); NSMutableArray *mutableList = [NSMutableArray arrayWithCapacity:count]; for (unsigned int i = 0; i \u0026lt; count; i++ ) { Protocol *protocol = protocolList[i]; const char *protocolName = protocol_getName(protocol); [mutableList addObject:[NSString stringWithUTF8String:protocolName]]; } return [NSArray arrayWithArray:mutableList]; } 使用[TestClass fetchProtocolList]获取TestClass类所遵循的协议列表的结果：　6、给类添加一个方法 下面的方法就是给类添加方法。第一个参数是方法的SEL，第二个参数则是提供方法实现的SEL。这个可以用在找不到某个方法时就添加一个，不然有可能会崩溃。详见Demo。\n+ (void)addMethod:(SEL)methodSel methodImp:(SEL)methodImp; { Method method = class_getInstanceMethod(self, methodImp); IMP methodIMP = method_getImplementation(method); const char *types = method_getTypeEncoding(method); class_addMethod(self, methodSel, methodIMP, types); } 7、交换实例方法 下面的方法就是将类的两个实例方法进行交换。如果将originMethod与currentMethod的方法实现进行交换的话，调用originMethod时就会执行currentMethod的内容。详见Demo。\n+ (void)swapMethod:(SEL)originMethod currentMethod:(SEL)currentMethod; { Method firstMethod = class_getInstanceMethod(self, originMethod); Method secondMethod = class_getInstanceMethod(self, currentMethod); method_exchangeImplementations(firstMethod, secondMethod); } 8、交换类方法 下面的方法就是将类的两个类方法进行交换，与交换实例方法类似，详见Demo。\n+ (void)swapClassMethod:(SEL)originMethod currentMethod:(SEL)currentMethod; { Method firstMethod = class_getClassMethod(self, originMethod); Method secondMethod = class_getClassMethod(self, currentMethod); method_exchangeImplementations(firstMethod, secondMethod); } 三、利用Runtime减少应用崩溃 利用交换方法可以减少程序中的崩溃，例如数组越界等等。demo里面的Safe文件夹就是一些防止崩溃的分类，直接放进工程就可以了。\n补充：如果有键盘推到后台崩溃的话，需要到build phase里给NSArray+Safe.m文件加上-fno-objc-arc标识。\n我们看一个例子，其他的大家可以去demo里面看。\n我们首先把__NSArrayI的objectAtIndex方法换成我们的ls_objectAtIndex，然后方法里面判断但是否越界，是的话直接返回nil：\n[NSClassFromString(@\u0026#34;__NSArrayI\u0026#34;) swapMethod:@selector(objectAtIndex:) currentMethod:@selector(ls_objectAtIndex:)]; - (id)ls_objectAtIndex:(NSUInteger)index { if (index \u0026gt;= [self count]) { return nil; } return [self ls_objectAtIndex:index]; } 然后当我们想下面这样写的时候就不会崩溃了：\nNSArray *array = @[@\u0026#34;aa\u0026#34;,@\u0026#34;ddd\u0026#34;]; array[5]; 好了，先说到这里吧。大家可以下载我的demo详细看一下。\n","date":"2017-06-03T14:18:38Z","permalink":"https://lisongrc.github.io/p/201706dfe7f658/","title":"Runtime的运用和减少应用崩溃"},{"content":"简介 Fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。\nGithub：https://github.com/fastlane/fastlane 官网：https://fastlane.tools/ 文档：https://docs.fastlane.tools/\n在写这篇文章的时候，他在Github上已经有15000+ star。\n安装 1、首先要安装正确的 Ruby 版本。在终端窗口中用下列命令来确认:\nruby -v 2、然后检查 Xcode 命令行工具是否安装。在终端窗口中输入命令：\nxcode-select --install 如果未安装，终端会开始安装，如果报错误：command line tools are already installed, use \u0026quot;Software Update\u0026quot; to install updates.代表已经安装。\n3、以上依赖配置好之后就可以通过 rubygem 进行安装了：\n$ sudo gem install fastlane 安心等待一会，fastlane就安装完成了。\n初始化 打开终端，cd到你的工程目录，然后执行fastlane init：\n$ cd to/your/ios/project $ fastlane init [14:21:43]: Detected iOS/Mac project in current directory... [14:21:43]: This setup will help you get up and running in no time. [14:21:43]: fastlane will check what tools you\u0026#39;re already using and set up [14:21:43]: the tool automatically for you. Have fun! [14:21:43]: Created new folder \u0026#39;./fastlane\u0026#39;. [14:21:43]: $ xcodebuild -showBuildSettings -project ./xxx.xcodeproj [14:21:48]: Your Apple ID (e.g. fastlane@krausefx.com): xxx@xxx.xom [14:21:54]: Verifying that app is available on the Apple Developer Portal and iTunes Connect... [14:21:54]: Starting login with user \u0026#39;xxx@xxx.com\u0026#39; +----------------+--------------------------------------+ | Detected Values | +----------------+--------------------------------------+ | Apple ID | xxx@xxx.com | | App Name | xxx | | App Identifier | com.xxx.xxx | | Project | /Users/lisong/Desktop/xxx/x | | | xx.xcodeproj | +----------------+--------------------------------------+ [14:22:06]: Please confirm the above values (y/n) y [14:22:09]: Created new file \u0026#39;./fastlane/Appfile\u0026#39;. Edit it to manage your preferred app metadata information. [14:22:09]: Loading up \u0026#39;deliver\u0026#39;, this might take a few seconds [14:22:09]: Login to iTunes Connect (xxx@xxx.com) [14:22:13]: Login successful +-----------------------+------------------------+ | deliver 2.30.1 Summary | +-----------------------+------------------------+ | screenshots_path | ./fastlane/screenshots | | metadata_path | ./fastlane/metadata | | username | xxx@xxx.com | | app_identifier | com.xxx.xxx | | edit_live | false | | platform | ios | | skip_binary_upload | false | | skip_screenshots | false | | skip_metadata | false | | force | false | | submit_for_review | false | | automatic_release | false | | dev_portal_team_id | WKR87TTKML | | overwrite_screenshots | false | +-----------------------+------------------------+ [14:22:21]: Writing to \u0026#39;fastlane/metadata/zh-Hans/description.txt\u0026#39; ... [14:22:21]: Writing to \u0026#39;fastlane/metadata/review_information/notes.txt\u0026#39; [14:22:21]: Successfully created new configuration files. [14:22:22]: Successfully downloaded large app icon [14:22:22]: Downloading all existing screenshots... [14:22:27]: Downloading existing screenshot \u0026#39;1_iphone4_1.1.jpg\u0026#39; for language \u0026#39;zh-Hans\u0026#39; ··· [14:22:34]: Downloading existing screenshot \u0026#39;5_iphone6_5.5.jpg\u0026#39; for language \u0026#39;zh-Hans\u0026#39; [14:22:34]: Successfully downloaded all existing screenshots [14:22:34]: Successfully created new Deliverfile at path \u0026#39;fastlane/Deliverfile\u0026#39; [14:22:34]: $ xcodebuild -list -project ./xxx.xcodeproj [14:22:35]: \u0026#39;snapshot\u0026#39; not enabled. [14:22:35]: \u0026#39;cocoapods\u0026#39; enabled. [14:22:35]: \u0026#39;carthage\u0026#39; not enabled. [14:22:35]: Created new file \u0026#39;./fastlane/Fastfile\u0026#39;. Edit it to manage your own deployment lanes. [14:22:35]: fastlane will collect the number of errors for each action to detect integration issues [14:22:35]: No sensitive/private information will be uploaded [14:22:35]: Learn more at https://github.com/fastlane/fastlane#metrics [14:22:35]: Successfully finished setting up fastlane 在 \u0026ldquo;Your Apple ID\u0026rdquo; 这一步输入苹果开发者账号。在“Please confirm the above values”这一步，确认信息，没问题输入 y。然后，fastlane 会进行一系列的初始化操作，包括下载 App Store 上的元数据和截屏文件。\n等待初始化完成之后，工程目录下就多了一个 fastlane目录，其内容如下：\n咱们来看两个主要的，Appfile和Fastfile。\nAppfile Appfile用来存放app_identifier，apple_id和team_id。 了解详情，它的格式是这样的：\napp_identifier \u0026#34;com.xxx.xxx\u0026#34; # app的bundle identifier apple_id \u0026#34;xxx@xxx.com\u0026#34; # 你的Apple ID team_id \u0026#34;XXXXXXXXXX\u0026#34; # Team ID ··· 你也可以为每个lane(后面会讲到)提供不同的 app_identifier, apple_id 和 team_id，例如：\napp_identifier \u0026#34;com.aaa.aaa\u0026#34; apple_id \u0026#34;aaa@aaa.com\u0026#34; team_id \u0026#34;AAAAAAAAAA\u0026#34; for_lane :inhouse do app_identifier \u0026#34;com.bbb.bbb\u0026#34; apple_id \u0026#34;bbb@bbb.com\u0026#34; team_id \u0026#34;AAAAAAAAAA\u0026#34; end 这里就是为Fastfile中定义的:inhouse设置单独的信息。\nFastfile Fastfile管理你所创建的 lane， 了解详情。它的格式是这样的：\n··· # 自动更新fastlane 工具 # update_fastlane #需要的fastlane的最小版本，在每次执行之后会检查是否有新版本，如果有会在最后末尾追加新版本提醒 fastlane_version \u0026#34;2.30.1\u0026#34; #默认使用平台是 ios，也就是说文件可以定义多个平台 default_platform :ios platform :ios do before_all do # ENV[\u0026#34;SLACK_URL\u0026#34;] = \u0026#34;https://hooks.slack.com/services/...\u0026#34; cocoapods end desc \u0026#34;Runs all the tests\u0026#34; lane :test do scan end desc \u0026#34;提交一个新的Beta版本到 Apple TestFlight\u0026#34; desc \u0026#34;This will also make sure the profile is up to date\u0026#34; lane :beta do # match(type: \u0026#34;appstore\u0026#34;) # more information: https://codesigning.guide gym(scheme: \u0026#34;Docment\u0026#34;) # Build your app - more options available pilot # sh \u0026#34;your_script.sh\u0026#34; end desc \u0026#34;部署一个新版本到App Store\u0026#34; lane :release do # match(type: \u0026#34;appstore\u0026#34;) # snapshot gym(scheme: \u0026#34;Docment\u0026#34;) # Build your app - more options available deliver(force: true) # frameit end # 你可以定义自己的lane #执行lane成功后的回调 after_all do |lane| # slack( # message: \u0026#34;Successfully deployed new App Update.\u0026#34; # ) end # 如果流程发生异常会走这里并终止 error do |lane, exception| # slack( # message: exception.message, # success: false # ) end end 我们也可以定义一个自己的lane：\ndesc \u0026#34;企业版\u0026#34; lane :inHouse do gym(scheme: \u0026#34;XXX\u0026#34;, export_method:\u0026#34;enterprise\u0026#34;, output_directory:\u0026#34;./build\u0026#34;, # 打包后的 ipa 文件存放的目录 output_name:\u0026#34;XXX.ipa\u0026#34; # ipa 文件名 ) end 其中一个lane就是一个任务，里面是一个个的action组成的工作流。 利用目前支持的工具可以做所有包含自动化和可持续化构建的每个环节，例如：\nscan 自动化测试工具，很好的封装了 Unit Test sigh 针对于 iOS 项目开发证书和 Provision file 的下载工具 match 同步团队每个人的证书和 Provision file 的超赞工具 gym 针对于 iOS 编译打包生成 ipa 文件 deliver 用于上传应用的二进制代码，应用截屏和元数据到 App Store snapshot 可以自动化iOS应用在每个设备上的本地化截屏过程\n执行 定义完lane之后怎么执行呢？打开终端，切换到项目的根目录：执行fastlane lane'name就可以了。成功之后会在相应的路径下生成ipa文件，如果报错的话就根据错误信息好好查看文档。\n其他 1、这里是官方提供的一些例子。\n2、想了解fastlane命令的话可以执行$ fastlane --help\n3、查看可用任务的列表，可以执行命令$ fastlane lanes\n4、fastlane也提供了很多插件方便我们使用，例如pgyer(发布app到蒲公英)。我们也可以打完包直接传到蒲公英上，具体的可以看蒲公英提供的文档。\n如果你感觉有些插件不符合自己的情况，你甚至可以自定义插件\n5、多个 lane 的话实际上是可以相互调用的，这个其实特别实用。例如：\ndefault_platform :ios platform :ios do lane :prepare do cocoapods match end desc \u0026#39;fastlane build\u0026#39; \u0026#39;fastlane build type:adhoc\u0026#39; lane :build do |options| # 调用上面的 prepare 任务 prepare case options[:type] when \u0026#39;adhoc\u0026#39; adhoc else appstore end end lane : adhoc do ··· end lane : appstore do ··· end end 6、我们可以在 Fastfile 文件中添加一个函数来设置version号和build号。\ndefault_platform :ios def prepare_version(options) increment_version_number( version_number: options[:version] ) increment_build_number( build_number: options[:build] ) end 然后可以在一个lane中使用这个函数：\nlane :appstore do |options| ··· prepare_version(options) ··· end 然后执行这个lane的时候：\n$ fastlane appstore version:2.4.0 build:2.0 好啦，先说到这里吧，Fastlane能做的事情还有很多，大家可以去好好看看文档，研究一些高级的用法吧！\n","date":"2017-05-14T00:12:27Z","permalink":"https://lisongrc.github.io/p/201705146f90c7/","title":"iOS中使用Fastlane实现自动化打包和发布"},{"content":"好久没来写文章了，因为生活中有一些琐事，也因为工作比较忙。今天我们来聊聊Xcode的自定义模板。\n为何要自定义Xcode模板 有时候公司会要求一定的代码规范，例如控制器中需要用#pragma mark - 来分割各个方法们，像这样：\n#pragma mark - LifeCycle - (void)dealloc {} - (void)viewDidLoad {} - (void)viewWillAppear:(BOOL)animated {} #pragma mark - UITextFieldDelegate - (BOOL)textFieldShouldReturn:(UITextField *)textField {} #pragma mark - Public #pragma mark - Private #pragma mark - Getter - (NSString *)name {} #pragma mark - Setter - (void)setName:(NSString *)name {} 这样不仅可以分割代码，方便阅读，而且可以方便找到某个方法： 但是每创建一个类就写一遍这些是不是有点繁琐呢，这个时候就要用到Xcode的自定义模板功能了。\n修改系统模板样式 Xcode系统模板的路径是/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/，文件夹里面有文件模板File Templates和工程模板Project Templates，分别对应创建文件时的选项和创建工程时的选项：\n我们用的最多就是File Templates/Source/Cocoa Touch Class.xctemplate里面的模板。里面长的是这样的： 例如我们今天需要改UIViewController的模板，就需要改其中的UIViewControllerObjective-C、 UIViewControllerSwift、UIViewControllerXIBObjective-C、UIViewControllerXIBSwift。他们的区别从名字上就能看出来，就是OC与Swift，是否用Xib的区别。\n我们以OC并且不用Xib为例，打开UIViewControllerObjective-C中的___FILEBASENAME___.m文件：\n// // ___FILENAME___ // ___PROJECTNAME___ // // Created by ___FULLUSERNAME___ on ___DATE___. //___COPYRIGHT___ // #import \u0026#34;___FILEBASENAME___.h\u0026#34; @interface ___FILEBASENAMEASIDENTIFIER___ () @end @implementation ___FILEBASENAMEASIDENTIFIER___ - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. } /* #pragma mark - Navigation // In a storyboard-based application, you will often want to do a little preparation before navigation - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { // Get the new view controller using [segue destinationViewController]. // Pass the selected object to the new view controller. } */ @end 是不是很熟悉，就是我们创建一个控制器后.m里面的代码。其中的一些宏的意义是：\n宏名 意义 ___FILENAME___ 文件名包括后缀 ___PROJECTNAME___ 工程名 ___FULLUSERNAME___ 用户的名字 ___DATE___ 当前日期，年/月/日 ___COPYRIGHT___ 版权 ___FILEBASENAME___ 不带后缀的文件名 ___FILEBASENAMEASIDENTIFIER___ 不带后缀的文件名 这个文件默认是不让修改的，我们可以修改他的权限，或者复制一份到别处，修改完替换原文件。总之修改其中的内容为：\n// // ___FILENAME___ // ___PROJECTNAME___ // // Created by ___FULLUSERNAME___ on ___DATE___. //___COPYRIGHT___ // #import \u0026#34;___FILEBASENAME___.h\u0026#34; @interface ___FILEBASENAMEASIDENTIFIER___ () @end @implementation ___FILEBASENAMEASIDENTIFIER___ #pragma mark - LifeCycle - (void)viewDidLoad { [super viewDidLoad]; } #pragma mark - UITableViewDelegate #pragma mark - Public #pragma mark - Private #pragma mark - Getter #pragma mark - Setter @end 然后把这个文件去替换原来的文件。替换成功后新建一个控制器，就会是我们自定义的结构了，如果没生效的话，可以重启下Xcode哦： 相信到这里，其他的模板你也一定会改了吧。\n使用自定义模板 如果更改系统模板会有问题，就是xcode更新后我们所做的更改就没有了。 为了解决这个问题，我们可以在~/Library/Developer/Xcode/Templates路径下新建一个Templates文件夹，再在Templates里新建一个Custom的文件夹，把系统的Cocoa Touch Class.xctemplate复制进去，然后进行修改就可以了。\n这样在创建文件的时候，在最下面就会有你自定义的模板选项: 好了，到这里大家应该都熟悉了Xcode模板的基本使用，快去探索更多高级用法吧！\n","date":"2017-04-13T00:11:43Z","permalink":"https://lisongrc.github.io/p/201704535c2bd8/","title":"Xcode自定义模板实践"},{"content":"什么是Universal Links? 在iOS9之前，对于从各种从浏览器、Safari中唤醒APP的需求，我们通常只能使用scheme。但是这种方式需要提前判断系统中是否安装了能够响应此scheme的app，并且这种方式在微信中是被禁用了的。\nUniversal Links是iOS9推出的一项功能，使你的应用可以通过传统的HTTP链接来启动APP(如果iOS设备上已经安装了你的app，不管在微信里还是在哪里)， 或者打开网页(iOS设备上没有安装你的app)。\n下面简单说下怎么使用Universal Links，具体的可以看官方的说明文档\n怎么使用Universal Links 1.先决条件：你必须有一个域名,且这个域名需要支持https。\n2.需要在开发者中心做配置：找到对应的App ID，在Application Services列表里有Associated Domains一条，把它变为Enabled就可以了。 3.打开工程配置中的Associated Domains，在其中的Domains中填入你想支持的域名，必须以**applinks:**为前缀。\n4.创建一个内容为json格式的文件，苹果将会在合适的时候，从我们在项目中填入的域名请求这个文件。这个文件名必须为apple-app-site-association，没有后缀名，文件内容大概是这样子：\n{ \u0026#34;applinks\u0026#34;: { \u0026#34;apps\u0026#34;: [], \u0026#34;details\u0026#34;: [ { \u0026#34;appID\u0026#34;: \u0026#34;9JA89QQLNQ.com.apple.wwdc\u0026#34;, \u0026#34;paths\u0026#34;: [ \u0026#34;/wwdc/news/\u0026#34;, \u0026#34;/videos/wwdc/2015/*\u0026#34;] }, { \u0026#34;appID\u0026#34;: \u0026#34;ABCD1234.com.apple.wwdc\u0026#34;, \u0026#34;paths\u0026#34;: [ \u0026#34;*\u0026#34; ] } ] } } 说明：\nappID：组成方式是 teamId.yourapp’s bundle identifier。如上面的 9JA89QQLNQ就是teamId。登陆开发者中心，在Account - Membership里面可以找到Team ID。\npaths：设定你的app支持的路径列表，只有这些指定的路径的链接，才能被app所处理。星号的写法代表了可识别域名下所有链接。\n这篇博客里有很多其他公司的例子，可以参考一下。也有可能有的公司的已经不再适用，可以换换其他公司的。\n5.上传该文件到你的域名所对应的根目录或者.well-known目录下，这是为了苹果能获取到你上传的文件。上传完后,自己先访问一下,看看是否能够获取到，当你在浏览器中输入这个文件链接后，应该是直接下载apple-app-site-association文件。\n验证 在iOS设备中的备忘录中输入App能识别的链接，然后直接点击此链接，就会直接跳转到你的app了。或是长按，在出现的弹出菜单中第二项是在’XXX’中打开，这也代表着成功：\n或是你将要测试的网址在safari中打开，在出现的网页上方下滑，可以看到有在”XX”应用中打开： 在微信的网页浏览器中也是可以的，虽然微信屏蔽了所有的scheme方式跳转到其它app，但是Universal Links是由系统直接处理的，微信屏蔽不了，这也就实现了从微信跳转到我们的app。\n苹果为了方便开发者，提供了一个网页来验证我们编写的这个apple-app-site-association是否合法有效，进入验证网址进行验证：\n进入app后的处理 现在用户点击某个链接，直接可以进我们的app了，但是我们的目的是要能够获取到用户进来的链接，根据链接来展示给用户相应的内容。 我们需要在工程里的 AppDelegate 里实现方法\n- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler { if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) { NSURL *url = userActivity.webpageURL; if (url是我们希望处理的) { //进行我们的处理 } else { [[UIApplication sharedApplication] openURL:url]; } } return YES; } 注意 前端开发经常面临跨域问题，必须要求跨域，如果不跨域，就不行。 只有当前webview的url域名，与跳转目标url域名不一致时，Universal Link 才生效。\n好了先说到这里，如果遇到什么问题可以详细看官方的说明文档。\n","date":"2017-02-03T16:09:40Z","permalink":"https://lisongrc.github.io/p/20170242f0d4d/","title":"iOS 9 通用链接（Universal Links）"},{"content":"有的时候我们想要将程序运行过程中产生的Log保存起来或者发送到自己服务器，为了以后方便分析。这时候就可以用CocoaLumberjack啦。\nCocoaLumberjack是一个可以在iOS和Mac开发中使用的日志库，强大又不失灵活。集成进项目后，配置下，然后用DDLog语句简单地取代NSLog语句（ DDLog的使用方法和NSLog一样）就可以啦，是不是很方便。\n安装 第一种方法：使用cocoapods，不会使用cocoapods的可以看这篇教程，Podfile看起来是这样的：\nplatform:ios, \u0026#39;7.0\u0026#39; target \u0026#39;CocoaLumberjackDemo\u0026#39; do pod \u0026#39;CocoaLumberjack\u0026#39; end 第二种方法：使用Carthage，Cartfile：\ngithub \u0026#34;CocoaLumberjack/CocoaLumberjack\u0026#34; 第三种方法：手工导入，具体可以看他的文档\n使用 CocoaLumberjack自带了几种Log方式：\n1.DDLog（整个框架的基础） 2.DDASLLogger（发送日志语句到苹果的日志系统，以便它们显示在Console.app上） 3.DDTTYLoyger（发送日志语句到Xcode控制台） 4.DDFIleLoger（把日志写入本地文件）\n你可以同时记录文件和控制台，还可以创建自己的logger，将日志语句发送到网络或者数据库中。\n使用的时候需要引入头文件：#import \u0026lt;CocoaLumberjack/CocoaLumberjack.h\u0026gt;，你还需要全局设置下log级别： static const DDLogLevel ddLogLevel = DDLogLevelDebug;，关于Log级别，下面会细讲。\n所以你的.pch里面可能有段这样的代码： 然后加入代码：\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // 添加DDASLLogger，你的日志语句将被发送到Xcode控制台 [DDLog addLogger:[DDTTYLogger sharedInstance]]; // 添加DDTTYLogger，你的日志语句将被发送到Console.app [DDLog addLogger:[DDASLLogger sharedInstance]]; // 添加DDFileLogger，你的日志语句将写入到一个文件中，默认路径在沙盒的Library/Caches/Logs/目录下，文件名为bundleid+空格+日期.log。 DDFileLogger *fileLogger = [[DDFileLogger alloc] init]; fileLogger.rollingFrequency = 60 * 60 * 24; fileLogger.logFileManager.maximumNumberOfLogFiles = 7; [DDLog addLogger:fileLogger]; //产生Log DDLogVerbose(@\u0026#34;Verbose\u0026#34;); DDLogDebug(@\u0026#34;Debug\u0026#34;); DDLogInfo(@\u0026#34;Info\u0026#34;); DDLogWarn(@\u0026#34;Warn\u0026#34;); DDLogError(@\u0026#34;Error\u0026#34;); return YES; } DDLog和NSLog的语法是一样的。\n运行程序，可以在Xocde控制台看到： 产生的Log文件打开是这样的： Log级别 接下来，你就要考虑用哪种级别了，CocoaLumberjack有5种：\ntypedef NS_OPTIONS(NSUInteger, DDLogFlag){ DDLogFlagError = (1 \u0026lt;\u0026lt; 0), DDLogFlagWarning = (1 \u0026lt;\u0026lt; 1), DDLogFlagInfo = (1 \u0026lt;\u0026lt; 2), DDLogFlagDebug = (1 \u0026lt;\u0026lt; 3), DDLogFlagVerbose = (1 \u0026lt;\u0026lt; 4) }; Log Level 用来过滤每条Log：\ntypedef NS_ENUM(NSUInteger, DDLogLevel){ DDLogLevelOff = 0, DDLogLevelError = (DDLogFlagError), DDLogLevelWarning = (DDLogLevelError | DDLogFlagWarning), DDLogLevelInfo = (DDLogLevelWarning | DDLogFlagInfo), DDLogLevelDebug = (DDLogLevelInfo | DDLogFlagDebug), DDLogLevelVerbose = (DDLogLevelDebug | DDLogFlagVerbose), DDLogLevelAll = NSUIntegerMax }; 例如，如果您将日志级别设置为 LOG_LEVEL_INFO，那么你会看到error、Warn和Info语句。\n你也可以自定义Log级别或者每个级别的名字或者在单纯的级别上增加一些高级用法\n我们也可以为Debug和Release模式设置不同的Log级别：\n#ifdef DEBUG static const DDLogLevel ddLogLevel = DDLogLevelVerbose; #else static const DDLogLevel ddLogLevel = DDLogLevelWarning; #endif 我们还可以为每种loger设置不同的级别：\n[DDLog addLogger:[DDASLLogger sharedInstance] withLevel:DDLogLevelInfo]; [DDLog addLogger:[DDTTYLogger sharedInstance] withLevel:DDLogLevelDebug]; 我们还可以自定义日志的formatter格式： 首先自定义一个 LogFormatter, 遵从 DDLogFormatter 协议，我们需要重写 - (NSString *)formatLogMessage:(DDLogMessage *)logMessage 这个方法，这个方法的输入参数是由 logger 发的一个 DDLogMessage 对象，包含了一些必要的信息，返回值就是最终 log 的消息体字符串。\n我们还可以自定义Logger，实现我们自己想要的处理，具体可以看他的文档。\n更多详细文档可以点这里\n","date":"2017-01-02T22:54:17Z","permalink":"https://lisongrc.github.io/p/201701269a2739/","title":"CocoaLumberjack：简单好用的Log库"},{"content":"由于最近琐事比较多，所以好久没有写文章了。今天我们聊一聊Objective-C自动生成文档。\n做项目的人多了，就需要文档了。手工写文档是一件苦差事，但是我们也有从源码中抽取注释生成文档的专用工具。\n经过查找，比较大众的有三个：\ndoxygen：适于生成html文档与pdf文档。 支持的语言多，可以配置的地方也比较多。默认生成的风格与苹果的风格不一致。\nheaddoc ：是 Xcode 自带的文档生成工具。在安装完 Xcode 后，就可以用命令行来生成对应的文档。不过它只生成以/*! */的格式的注释。不兼容 /** */格式的注释\nappledoc: Github地址 ，适于生成html文档和xcode帮助文档（docset）。可以兼容 /** */格式，也可以兼容 /*! */格式的注释。\n我感觉appledoc是最好的，所以在这里，我只介绍一下appledoc的使用，有兴趣的童鞋也可以研究下其他两种。\nappledoc的安装 第一种：打开终端，输入以下命令：\ngit clone git://github.com/tomaz/appledoc.git cd appledoc sudo sh install-appledoc.sh 第二种：如果你装了homebrew，打开终端，输入以下命令：\nbrew install appledoc appledoc的使用 为了演示appledoc的使用，我在桌面新建了一个工程Test，然后在ViewController类里面加了一些注释：\n然后演示appledoc的使用：\n1.在终端中使用 使用 appledoc 时，打开终端，进入项目所在目录，使用如下命令即可：\nappledoc --output 输出路径 --project-name 工程名 --project-company 公司名 --company-id 公司ID . 例如我在这里使用的命令是：\nappledoc --output ./doc --project-name Test --project-company lisong --company-id lisong . 具体过程如下： appledoc 会扫描当前路径下的所有文件，然后生成好文档放到 doc 目录下。 编译出的Docset 默认会放在~/Library/Developer/Shared/Documentation/DocSets路径下，里面包含html的文档。首先显示生成的Docset的包内容，然后在Contents/Resources/Documents路径下，双击打开里面的index.html可以在浏览器中查看文档了。\n并且生成的Docset已经安装到Xcode中。重启Xcode后，在Help—Documentation and API Reference菜单下也可以看到生成的文档： 如果不想生成Docset，而是想生成html，就需要加一个--no-create-docset，这里我使用命令：\nappledoc --no-create-docset --output ./doc --project-name Test --project-company lisong --company-id lisong . 则会在doc目录下生成一个html文件夹，也是双击里面的index.html就可以在浏览器中查看文档了。 你也可以在终端用appledoc --help查看所有可用的参数。详细的信息可以查看官方的文档：http://gentlebytes.com/appledoc/\n2.在Xcode里使用 1.首先创建一个Aggregate类型的Target，取名Document 2.选择Build Phases，点击左边的小加号，选择New Run Script Phase，建好了以后打开刚刚建立的Run Script，在框里输入命令，命令与终端一样，这里我们输入：\nappledoc --no-create-docset --output ./doc --project-name Test --project-company lisong --company-id lisong . 3..然后点左上角选择Document，编译一下，成功后文档就生成在doc目录下了。 注释样式 因为appledoc是通过注释生成文档的，下面说说注释的样式，几种常见的有：\n/// Single line comment. /// Single line comment spreading /// over multiple lines. /** Single line comment. */ /*! Single line comment */ /** * Single line comment spreading * over multiple lines. */ /** Single line comment spreading over multiple lines. No star */ 在Xcode里面，我们可以用command + option + /方便快捷地生成注释，很方便。大家可以多尝试尝试各种注释。更多的注释格式可以看这里\n","date":"2016-12-13T15:47:22Z","permalink":"https://lisongrc.github.io/p/201612db31073b/","title":"Objective-C自动生成文档工具:appledoc"},{"content":"如果我们有些功能要给别人用，但是又不想公开代码实现，比如高德地图、第三方登录分享等等，这时候我们就要打包成库了。库分静态库和动态库两种：\n静态库：以.a 和 .framework为文件后缀名。 动态库：以.tbd(之前叫.dylib) 和 .framework 为文件后缀名。\n静态库与动态库的区别 静态库：链接时会被完整的复制到可执行文件中，被多次使用就有多份拷贝。 动态库：链接时不复制，程序运行时由系统动态加载到内存，系统只加载一次，多个程序共用（如系统的UIKit.framework等），节省内存。\n但是苹果不让使用自己的动态库，否则审核就无法通过。\n我们先来看一下iOS设备有哪些架构，因为下面要用到：\n模拟器： iPhone4s-iPnone5：i386 iPhone5s-iPhone7 Plus：x86_64\n真机: iPhone3gs-iPhone4s：armv7 iPhone5-iPhone5c：armv7s iPhone5s-iPhone7 Plus：arm64\n支持armv7的静态库可以在armv7s上正常运行。\n.a静态库的制作 1、先创建一个新的Xcode工程Test，需要选择下面这个模板： 创建完成后是这个样子的： 2、我们把默认生成的Test.h和Test.m删掉，重新创建一个类PrintString，在这个类里面添加一个单纯打印字符串的简单方法: 3、选择添加公开头文件 为了让使用者知道有哪些方法可以用，我们需要公开头文件，这里我们公开PrintString.h： 4、修改配置 我们需要把Build Active Architecture Only修改为NO，否则生成的静态库就只支持当前选择设备的架构。 5、然后编译 我们分别选择Generic iOS Device和任意一个模拟器各编译一次，编译完后，我们会看到工程中Products文件夹下的libTest.a由红色变成了黑色，然后show in finder，看看生成的文件： 我们看到它为真机和模拟器都生成了.a静态库。里面都包含我们选择公开的头文件。\n我们来看看静态库支持的框架：命令为lipo -info 静态库名字 我们看到，Debug-iphoneos里面的静态库支持的架构有armv7和arm64所以它只能用于真机，在模拟器上会报错。Debug-iphonesimulator里面的静态库支持的架构有i386和x86_64，所以它只能用于模拟器，在真机上会报错。\n如果想要让模拟器和真机通用一个静态库，我们可以使用终端命令来实现。命令格式：lipo -create 第一个.a文件的绝对路径 第二个.a文件的绝对路径 -output 最终的.a文件路径: 我们看到生成了一个新的libTest.a文件。这个静态库就支持所有模拟器和所有真机了。然后我们创建一个文件夹，把.a和头文件都放进去，我们最终需要使用的就是这个文件夹： 注意：为了开发方便，我们可以使用生成的通用静态库，但是最终上线的使用我们可以只导入真机的，这样工程的体积也会小一些。\n使用生成的.a静态库 新建一个工程，将上面的通用静态库拖进去，导入头文件，就可以使用里面的方法了。经过试验，我们生成的静态库在真机上和模拟器上都能成功打印字符串： .frameworke静态库的制作 1、先创建一个新的Xcode工程LibTest，需要选择下面这个模板： 创建完成后是这个样子的： 创建完成后我们可以看到，工程本身自带一个LibTest.h文件和一个Info.plist文件。\n2、我们创建一个类PrintString，添加一个单纯打印字符串的简单方法: 3、选择添加公开头文件 为了让使用者知道有哪些方法可以用，我们需要公开头文件，我们需要在 并且将Target-\u0026gt;Build Phases-\u0026gt;Headers中的Project中要暴露的头文件拖拽到Pulic里面，这里我们公开PrintString.h： 注意：暴露出来的头文件中import的其他类也得添加到public中暴露出来。如果不想将import的类暴露出来，那么在头文件中用@class 然后在对应的.m文件中再import。\n4、设置支持所有架构（和.a制作一样） 5、修改生成的Mach-O格式，因为动态库也可以是以framework形式存在，所以需要设置，否则默认打出来的是动态库。将target-\u0026gt;BuildSetting-\u0026gt;Mach-o Type 设为Static Library（默认为Dynamic Library）: 6、编译 我们分别选择Generic iOS Device和任意一个模拟器各编译一次，编译完后，我们会看到工程中Products文件夹下的LibTest.framework由红色变成了黑色，然后show in finder，看看生成的文件： 我们看到它为真机和模拟器都生成了LibTest.framework静态库。\n我们来查看静态库支持的框架：与上面不同，命令为lipo -info framework下的二进制文件名字 如果想要让模拟器和真机通用一个静态库，我们可以使用终端命令来实现。合并的命令与上面不同的是：framework静态库合并的不是framework,而是framework下的二进制文件，命令为： lipo -create 第一个framework下二进制文件的绝对路径 第二个framework下二进制文件的绝对路径 -output 最终的二进制文件路径： 然后将任何一个framework中的二进制文件替换成合并后的二进制文件,然后把framework添加到要使用的项目中即可使用。\n使用生成的.framework静态库 新建一个工程，将静态库拖进去，导入头文件，就可以使用里面的方法了。经过试验，我们生成的静态库在真机上和模拟器上都能成功打印字符串： 注意： 如果静态库中有category类，则在使用静态库的项目配置中Other Linker Flags需要添加参数-ObjC或者-all_load。 如果创建的framework类中使用了.tbd，则需要在实际项目中导入.tbd动态库。\n运行调试静态库 如果你是开发静态库的人，你会发现上面的方法只是制作静态库，并没有办法运行看效果和调试bug，这时候我们可以这样： 1、新建一个专门用来开发静态库的正常工程Test： 2、添加一个静态库的target 我们看到它生成了几样东西:\n一个framework的target：在这里面修改静态库的配置们，例如支持的架构、要暴露的头文件们和Mach-O的配置。 一个LibTest文件夹：静态库里面的类们都放在这里面。 product文件夹下面的LibTest.framework：在这里show in finder找到编译后生成的静态库。\n3、开发调试代码 我们看到程序可以正常运行，并可以在动态库里面蹲点运行。方便我们调试。\n4、确保代码没问题后，选择对应的target编译生成。 5、后面的过程就与上面一样了。\n","date":"2016-11-07T15:33:05Z","permalink":"https://lisongrc.github.io/p/20161137f4228b/","title":"iOS中的静态库与动态库，区别、制作和使用"},{"content":"ios7之前我们实现二维码扫描是借助第三方(ZBar，ZXing等)来实现的，在ios7之后系统自己提供二维码扫描的方法，性能也要比第三方更好。\n今天就来介绍一下原生二维码的使用，包括扫描二维码，从图片扫描二维码和生成二维码。讲解中只展示部分代码，具体请看Github Demo，里面的代码不多，也很容易看懂。\n扫描二维码 二维码扫描需要用到AVFoundation.framework，需要用先创建一个AVCaptureSession，然后设置输入输出流，以及扫描区域和支持的格式：\n//获取摄像设备 AVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; //创建输入流 AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:nil]; if (!input) { return nil; } //创建输出流 AVCaptureMetadataOutput *output = [[AVCaptureMetadataOutput alloc] init]; //设置代理 在主线程里刷新 [output setMetadataObjectsDelegate:self queue:dispatch_get_main_queue()]; //设置扫描区域的比例 CGFloat width = 300 / CGRectGetHeight(self.view.frame); CGFloat height = 300 / CGRectGetWidth(self.view.frame); output.rectOfInterest = CGRectMake((1 - width) / 2, (1- height) / 2, width, height); AVCaptureSession *session = [[AVCaptureSession alloc] init]; //高质量采集率 [session setSessionPreset:AVCaptureSessionPresetHigh]; [session addInput:input]; [session addOutput:output]; //设置扫码支持的编码格式(这里设置条形码和二维码兼容) output.metadataObjectTypes = @[AVMetadataObjectTypeQRCode, AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeCode128Code]; 然后用这个session生成一个AVCaptureVideoPreviewLayer加到某个view的layer上，就可以实时显示摄像头捕捉的内容了：\nAVCaptureVideoPreviewLayer *layer = [AVCaptureVideoPreviewLayer layerWithSession:self.session]; layer.videoGravity = AVLayerVideoGravityResizeAspectFill; layer.frame = self.view.layer.bounds; [self.view.layer insertSublayer:layer atIndex:0]; 然后调用 [self.session startRunning];开始捕获，当扫描出结果后会调用下面的代理方法，其中metadataObject.stringValue就是扫描后的结果。\n#pragma mark - AVCaptureMetadataOutputObjectsDelegate -(void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection { if (metadataObjects.count \u0026gt; 0) { AVMetadataMachineReadableCodeObject *metadataObject = [metadataObjects firstObject]; } } 为了在黑夜也可以很好的扫描，可以设置一个闪光灯的开关：\n#pragma mark - 开关闪光灯 - (void)rightBarButtonDidClick:(UIBarButtonItem *)item { self.flashOpen = !self.flashOpen; AVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; if ([device hasTorch] \u0026amp;\u0026amp; [device hasFlash]) { [device lockForConfiguration:nil]; if (self.flashOpen) { device.torchMode = AVCaptureTorchModeOn; device.flashMode = AVCaptureFlashModeOn; } else { device.torchMode = AVCaptureTorchModeOff; device.flashMode = AVCaptureFlashModeOff; } [device unlockForConfiguration]; } } 从图片扫描 有时候我们需要从图片中扫描二维码，或者从相册选择一张图片，代码如下，具体可以看demo。其中feature.messageString就是扫描后的结果。\n- (void)findQRCodeFromImage:(UIImage *)image { CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:nil options:@{CIDetectorAccuracy:CIDetectorAccuracyHigh}]; NSArray *features = [detector featuresInImage:[CIImage imageWithCGImage:image.CGImage]]; if (features.count \u0026gt;= 1) { CIQRCodeFeature *feature = [features firstObject]; } } 生成二维码 生成二维码的代码很简单，代码如下。\n/** 生成指定大小的黑白二维码 */ - (UIImage *)createQRImageWithString:(NSString *)string size:(CGSize)size { NSData *stringData = [string dataUsingEncoding:NSUTF8StringEncoding]; CIFilter *qrFilter = [CIFilter filterWithName:@\u0026#34;CIQRCodeGenerator\u0026#34;]; // NSLog(@\u0026#34;%@\u0026#34;,qrFilter.inputKeys); [qrFilter setValue:stringData forKey:@\u0026#34;inputMessage\u0026#34;]; [qrFilter setValue:@\u0026#34;M\u0026#34; forKey:@\u0026#34;inputCorrectionLevel\u0026#34;]; CIImage *qrImage = qrFilter.outputImage; //放大并绘制二维码 (上面生成的二维码很小，需要放大) CGImageRef cgImage = [[CIContext contextWithOptions:nil] createCGImage:qrImage fromRect:qrImage.extent]; UIGraphicsBeginImageContext(size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetInterpolationQuality(context, kCGInterpolationNone); //翻转一下图片 不然生成的QRCode就是上下颠倒的 CGContextScaleCTM(context, 1.0, -1.0); CGContextDrawImage(context, CGContextGetClipBoundingBox(context), cgImage); UIImage *codeImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); CGImageRelease(cgImage); return codeImage; } 上面默认生成的时黑白二维码，不过我们也可以改颜色：\n/** 为二维码改变颜色 */ - (UIImage *)changeColorForQRImage:(UIImage *)image backColor:(UIColor *)backColor frontColor:(UIColor *)frontColor { CIFilter *colorFilter = [CIFilter filterWithName:@\u0026#34;CIFalseColor\u0026#34; keysAndValues: @\u0026#34;inputImage\u0026#34;,[CIImage imageWithCGImage:image.CGImage], @\u0026#34;inputColor0\u0026#34;,[CIColor colorWithCGColor:frontColor.CGColor], @\u0026#34;inputColor1\u0026#34;,[CIColor colorWithCGColor:backColor.CGColor], nil]; return [UIImage imageWithCIImage:colorFilter.outputImage]; } 有的二维码也会在中心加一个小图片，例如用户头像，代码如下：\n/** 在二维码中心加一个小图 */ - (UIImage *)addSmallImageForQRImage:(UIImage *)qrImage { UIGraphicsBeginImageContext(qrImage.size); [qrImage drawInRect:CGRectMake(0, 0, qrImage.size.width, qrImage.size.height)]; UIImage *image = [UIImage imageNamed:@\u0026#34;small\u0026#34;]; CGFloat imageW = 50; CGFloat imageX = (qrImage.size.width - imageW) * 0.5; CGFloat imgaeY = (qrImage.size.height - imageW) * 0.5; [image drawInRect:CGRectMake(imageX, imgaeY, imageW, imageW)]; UIImage *result = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return result; } 其实也可以扫描条形码，大家可以对着条形码试一试，代码都是通用的。\n","date":"2016-11-02T15:54:18Z","permalink":"https://lisongrc.github.io/p/201611963e6639/","title":"详细易懂的二维码的扫描、识别与生成"},{"content":"这篇文章我们来讲一下UITableView的cell自适应高度，以及遇到的问题的解决办法。在看文章之前希望你已经会UITableView的基本使用了。\n先奉上这篇文章的demo的Github地址：UITableViewCellHeightDemo。大家可以下载下来和文章配合看。\ncell高度计算的历史 在iOS8之前，如果UITableViewCell的高度是动态的，如果想要显示正确的话，我们需要在下面这个UITableView的代理方法中，返回每一行的精确高度：\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath; 如果cell的控件很多，样式很复杂的话，在这里面我们就可能需要写很多代码去做一些复杂的计算，甚至可能导致滑动不流畅。\n后来也有一些人写了一些第三方去解决这个问题，例如UITableView-FDTemplateLayoutCell。只要给cell自上而下加好约束，它就可以帮我们去算cell的高度并且可以缓存，省去了我们自己写计算代码的成本。具体可以进链接里面看看它的demo。\n但是在iOS10的系统下， FDTemplateLayoutCell会卡界面，而且tableview的行数越多表现的越卡。\n而且苹果在iOS8之后，推出了一种超级简单的cell动态自适应的方法，使用起来比 FDTemplateLayoutCell也简单一些，而且现在iOS10都出来了，没有必要去支持iOS7了，所以最后我还是选择了用系统的办法。这样我们以后就再也不用写heightForRowAtIndexPath方法了哈哈哈。\n系统的cell自适应高度的使用方法 首先我们需要把cell上的控件自上而下加好约束，如果对约束不熟悉的话建议看看下面这两篇文章学习一下： [Auto Layout Tutorial in iOS 9 Part 1: Getting Started [Auto Layout Tutorial in iOS 9 Part 2: Constraints](http://www.raywenderlich.com/115444/auto-layout-tutorial-in-ios-9-part-2-constraints)\n用xib加约束和用masonry加代码约束都是可以的。注意约束一定要自上而下加好，让系统知道怎么去计算高度。在这篇文章的demo里面的cell加的约束是这样的：\n加好约束后，然后告诉tableView自己去适应高度就可以了。有两种写法：\nself.tableView.rowHeight = UITableViewAutomaticDimension; self.tableView.estimatedRowHeight = 100; 或者直接写这个代理方法就可以了\n- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath { return 100; } 这个的意思就是告诉tableView，你需要自己适应高度，我不给你算啦哈哈哈。但是我们需要告诉它一个大概高度，例如上面的100，理论上这个是可以随便写的，并不影响显示结果，但是越接近真实高度越好。\n来看下demo效果： 我们看到，cell已经自己适应内容算出了高度，是不是很方便呢哼哼。 具体的代码大家可以去demo看哦。\n其实section的header和footer也是可以自动适应的，对应的方法有：\n- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section; - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section; 但是我们在实际开发中，一般都是根本没有header和footer，有的话一般也是给一个固定高度。所以在这里就不讲解了，原理都一样。\n可能遇到的问题和解决办法 1.高度不对 有时候有可能运行出来后看到cell的高度显示的不对，就像这样： 这个问题是因为约束没有满足自上而下，从而系统不知道怎么去计算。解决办法就是去修改约束，直到满足为止。一定要好好理解约束啊！\n2.点击状态栏无法滚动到顶部 我们知道，如果界面中有UIScrollView的话，点击状态栏会让其滚动到顶部，就像这样：\n但是如果我们用了自动计算高度的方法，又调用了tableView的reloadData方法（例如我们的数据有分页的时候，加载完下一页的数据后会去刷新tableView）。这时候就会出现问题，点击状态栏就有几率不能精确滚动到顶部了： 解决这个问题的办法是去缓存cell的高度，代码如下：\n@property (nonatomic, strong) NSMutableDictionary *heightAtIndexPath;//缓存高度所用字典 #pragma mark - UITableViewDelegate -(CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath { NSNumber *height = [self.heightAtIndexPath objectForKey:indexPath]; if(height) { return height.floatValue; } else { return 100; } } - (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath { NSNumber *height = @(cell.frame.size.height); [self.heightAtIndexPath setObject:height forKey:indexPath]; } 解释一下，就是用一个字典做容器，在cell将要显示的时候在字典中保存这行cell的高度。然后在调用estimatedHeightForRowAtIndexPath方法时，先去字典查看有没有缓存高度，有就返回，没有就返回一个大概高度。\n缓存高度之后，在demo里面多试几次，发现点击状态栏已经可以精确滚动回顶部了： 这段代码其实可以写在viewController的基类里面，这样写一遍就可以每个地方都能缓存cell的高度了。详见demo。这样就完美了！\n好啦先说到这里吧，有问题记得联系我。\n","date":"2016-10-09T11:29:40Z","permalink":"https://lisongrc.github.io/p/20161055050fbf/","title":"UITableView自动计算cell高度并缓存，再也不用管高度啦"},{"content":"今天这篇我们将讲解子表达式和后向引用的使用。后面会持续更新。\n理解子表达式 通过(和)括起来的就是子表达式。\n下面是一个例子：用来匹配IP 地址的正则表达式。 IP 地址是由\u0026quot; . \u0026ldquo;分隔的四组数字，如12.159.46.200。因为每个部分的数字都可以为一个、两个或者三个数字字符，这个匹配模式可以表示为\\d{1,3}：\n正则表达式：\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3} 待匹配文本：12.159.46.200 匹配后结果：12.159.46.200 分析：每个\\d{1,3}的实例都匹配了 IP 地址的一个数字。四个数字则是被 \\. 表示的\u0026rdquo; . \u0026ldquo;分隔开的。\\d{1,3}\\.模式重复了三遍，因此可以使用重复操作来处理。下面是相同例子的另外一个版本：\n正则表达式：(\\d{1,3}\\.){3}\\d{1,3} 待匹配文本：12.159.46.200 匹配后结果：12.159.46.200\n分析：此模式可以和前面的效果是一样的。表达式\\d{1,3}\\. 使用(和)括起来从而组成子表达式。(\\d{1,3}\\.){3}重复了子表达式三次（也就是 IP 地址的前三个数字），最后的\\d{1,3}匹配最后的数字。\n使用子表达式来分组是很重要的，尽管这个例子中根本不包括重复。来看一个例子：\n正则表达式：19|20\\d{2} 待匹配文本：1967-08-17 匹配后结果：1967-08-17\n分析：19|20\\d{2}用来定位一个前两个数字只能为 19或者20 的四位数的年份。但是很显然这个正则并没有实现预想的效果。|操作符从左到右读取，将19|20\\d{2}分析为要么19 ，要么20\\d{2}，也就是匹配数字 19 或者20开头的四个数字字符。\n解决方法是将19|20作为一个子表达式，(19|20)\\d{2}就能够匹配所有19 和 20 开头的四个数字了。\n嵌套子表达式 子表达式可以嵌套。实际上，子表达式可以一层一层嵌套在子表达式内。为了演示嵌套子表达式的用法，我们再来看看查找 IP 地址的例子。\n其实上面例子中(\\d{1,3}\\.){3}\\d{1,3}匹配IP 地址是有问题的，因为非法的 IP 地址也将被匹配。IP 地址中的每个数字都是小于 255 的。而上面的模式可以匹配 300甚至是999 ，而这些实际上都是非法的 IP 地址。\n下面定义了所有合法 IP 地址所需要满足的一种条件：\n所有的一位数和两位数 三位数的第一位为 1 如果三位数的第一位为 2 ，且第二位从 0 到 4 如果三位数的前二位为 25 ，且第三位从 0 到 5\n当定义了需要匹配的情况后，就比较容易实现可以工作的模式。下面是个例子： (((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))\\.){3}((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))\n分析：这个模式可以工作的原因是一系列的嵌套子表达式。首先从(((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))\\.)子表达式开始。包含了四个嵌套子表达式。(\\d{1,2})可以匹配一位数和两位数(0到99)。(1\\d{2})匹配了任何第一位为 1 的三位数(100到199) 。(2[0-4]\\d)匹配数字从 200 到 249 。(25[0-5])匹配数字从 250 到 255 。每个子表达式都是通过“ | ”包括在另一个子表达式中。在数字范围之后是\\.表示的\u0026rdquo; . \u0026ldquo;，然后这个系列括起来作为子表达式并重复三遍（使用{3}）。最后，((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))被用来匹配最后一个 IP 地址的数字（没有了\\.后缀）。由于将四个数字都是限制在了 0 到 255 之间，所以此模式可以匹配所有的合法 IP 地址。\n理解后向引用 HTML 开发者经常使用标题标签（到，包括相应的结束标签到）。假设你需要定位所有的标题标签：\n正则表达式：\u0026lt;[hH][1-6]\u0026gt;.*?\u0026lt;/[hH][1-6]\u0026gt; 待匹配文本：title 1 — title 6 匹配后结果：\u0026lt;H1\u0026gt;title 1\u0026lt;/H1\u0026gt; — \u0026lt;H6\u0026gt;title 6\u0026lt;/H6\u0026gt;\n分析：\u0026lt;[hH][1-6]\u0026gt;可以匹配所有的开始标签，而\u0026lt;/[hH][1-6]\u0026gt;可以匹配所有的结束标签。\n注意：我们这里使用了.*?而不是.*。正如在上一篇文章解释的一样，*的量词是贪婪的，所以模式\u0026lt;[hH][1-6]\u0026gt;.*\u0026lt;/[hH][1-6]\u0026gt;将匹配从 直到 。所以可以使用非贪婪量词.*?来解决这个问题。\n接着看这个例子：\n正则表达式：\u0026lt;[hH][1-6]\u0026gt;.*?\u0026lt;/[hH][1-6]\u0026gt; 待匹配文本：title 匹配后结果：\u0026lt;H1\u0026gt;title\u0026lt;/H6\u0026gt;\n分析：采用 开始而采用 的标题标签是非法的，但是现在的模式可以匹配。问题在于匹配的第二个部分（匹配结束的标签）没有办法知道匹配第一部分（匹配开始的标签）是什么。这时候就需要后向引用了。\n使用后向引用匹配 后向应用就是引用前面的子表达式。你可以将后向应用理解成变量。例如\\1匹配模式中第一个子表达式。同理，\\2将匹配第二个子表达式，\\3将匹配第三个。我们结合例子来理解。一个子表达式可以通过后向引用根据需要引用多次。\n在上个例子中，\u0026lt;[hH][1-6]\u0026gt;.*?\u0026lt;/[hH][1-6]\u0026gt;会匹配非法的标题。我们可以使用后向引用来解决：\n正则表达式：\u0026lt;[hH]([1-6])\u0026gt;.*?\u0026lt;/[hH]\\1\u0026gt; 待匹配文本：title—title 匹配后结果：\u0026lt;H1\u0026gt;title\u0026lt;/H1\u0026gt;—title\n分析：就像以前一样，\u0026lt;[hH]([1-6])\u0026gt;将匹配任何的标题标签。但是和以前不一样的是，这里的[1-6] 使用了小括号括起来成为了子表达式。这样，匹配结束标签的模式可以通过\u0026lt;/[hH]\\1\u0026gt;中的\\1来引用此子表达式。(1-6)是一个可以匹配数字 1 到 6 的子表达式，\\1因此可以匹配相同的数字。在这种情况下，\u0026quot;title\u0026ldquo;将不能匹配。\n注意：后向引用只能够引用子表达式（需要使用小括号括起来），后向引用语法在不同的正则表达式实现中可能是不一样的。引用的匹配一般是从 1 开始。在大多数的正则表达式实现中，0 可以用来引用整个表达式。\n执行替换操作 到现在为止我们所看到的正则表达式都是进行搜索，在一段文本中定位单词。正则表达式还可以用来执行替换操作。举个例子，将CA 替换成California和将MI替换成Michigan 并不是正则表达式需要完成的工作。尽管使用正则表达式也是合法的，但是没有必要这么做。事实上，在这里如果使用简单的字符串操作函数的话过程将会变得更加容易。\n让我们来看一个例子，将313-555-1234格式的电话号码重新格式化为(313) 555-1234格式：\n查找表达式：(\\d{3})(-)(\\d{3})(-)(\\d{4}) 替换表达式：($1) $3-$5\n文本 313-555-1234 248-555-9999\n结果 (313) 555-1234 (248) 555-9999\n分析：(\\d{3})(-)(\\d{3})(-)(\\d{4})匹配了一个电话号码，并分成了五个子表达式。(\\d{3})匹配刚开始的三个数字并作为第一个子表达式，(-)匹配\u0026rdquo; - \u0026ldquo;并作为第二个子表达式，依此类推。这五个部分可以根据需要单独引用，($1) $3-$5只是使用了其中的三个子表达式。因此“313-555-1234”改变为了“(313) 555-1234”。\n在Xcode中查找和替换文本： 查找 替换 其实正则表达式还是很简单的，大家可以多找些例子熟悉一下。用的多了就熟了。\n正则表达式在iOS中的使用。 NSPredicate NSPredicate通常用来验证一个字符串是不是符合某种格式，例如验证一个字符串是不是由数字和字母组成的：\n//待匹配字符串 NSString *string = @\u0026#34;song123\u0026#34;; //正则表达式 NSString *regex = @\u0026#34;^[a-z0－9A-Z]*$\u0026#34;; //创建predicate NSPredicate *predicate = [NSPredicate predicateWithFormat:@\u0026#34;SELF MATCHES %@\u0026#34;, regex]; //用predicate匹配string。result为匹配结果，YES or NO。 BOOL result = [predicate evaluateWithObject:string]; 关于NSPredicate还有一些其他的可以使用方法们，具体可以查看官方API。\nNSString NSString可以用正则来查找自己当中符合要求的子字符串，例如查找字符串中的数字：\n//待匹配字符串 NSString *string = @\u0026#34;song123\u0026#34;; //使用正则\\d+去string中进行匹配，得到的时匹配到的range，在这里为{4，3}。 NSRange range = [string rangeOfString:@\u0026#34;\\\\d+\u0026#34; options:NSRegularExpressionSearch]; //如果匹配到就打印匹配到的子字符串，在这里为123。 if (range.location != NSNotFound) { NSLog(@\u0026#34;%@\u0026#34;,[string substringWithRange:range]); } 分析：\\d+用来查找数字，rangeOfString:options:会返回一个NSRange，用来接收匹配的范围。options必须要用NSRegularExpressionSearch，代表用正则去匹配。range.location==NSNotFound的话代表匹配不到结果。当写正则字符串时，\\\\ 需要写成\\\\\\\\ ，所以，\\d+需要写成\\\\\\\\d+。\nNSRegularExpression 对于匹配字符串中的数字，我们也可以用到NSRegularExpression这个类实现。它可以用户来查找字符串中符合要求的第一个匹配结果或者所有匹配结果。\n查找字符串中第一个匹配结果\n//待匹配字符串 NSString *string = @\u0026#34;123abc45fgt7tyu\u0026#34;; //正则表达式 NSString *pattern = @\u0026#34;\\\\d+\u0026#34;; //创建NSRegularExpression对象并指定正则表达式 NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:NSRegularExpressionCaseInsensitive error:nil]; //查找第一个匹配结果，如果查找不到的话match会是nil NSTextCheckingResult *match = [regex firstMatchInString:string options:NSMatchingReportCompletion range:NSMakeRange(0, [string length])]; if (match) { //如果查找到就打印出来，结果为123 NSLog(@\u0026#34;%@\u0026#34;,[string substringWithRange:match.range]); } 分析：firstMatchInString:options:range会查找字符串中第一个匹配，所以123abc45fgt7tyu的匹配结果为123。\n查找字符串中所有匹配结果\n//待匹配字符串 NSString *string = @\u0026#34;123abc45fgt7tyu\u0026#34;; //正则表达式 NSString *pattern = @\u0026#34;\\\\d+\u0026#34;; //创建NSRegularExpression对象并指定正则表达式 NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:NSRegularExpressionCaseInsensitive error:nil]; //查找所有匹配结果 NSArray* matches = [regex matchesInString:string options:NSMatchingReportProgress range:NSMakeRange(0, [string length])]; //如果有匹配就打印出来，结果为123 45 7 if (matches.count \u0026gt; 0) { for (NSTextCheckingResult *match in matches) { NSLog(@\u0026#34;%@\u0026#34;,[string substringWithRange:match.range]); } } 分析：matchesInString:options:range:会查找字符串中的所有匹配，结果是一个包含NSTextCheckingResult的数组。所以123abc45fgt7tyu的匹配结果为123、45和7。\n创建NSRegularExpression对象时的options参数为NSRegularExpressionOptions类型，可选值以及代表的意义如下：\ntypedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) { NSRegularExpressionCaseInsensitive = 1 \u0026lt;\u0026lt; 0, //不区分大小写 NSRegularExpressionAllowCommentsAndWhitespace = 1 \u0026lt;\u0026lt; 1, //忽略空白和注释 NSRegularExpressionIgnoreMetacharacters = 1 \u0026lt;\u0026lt; 2, //将所有的patter当作普通字符串 NSRegularExpressionDotMatchesLineSeparators = 1 \u0026lt;\u0026lt; 3, // 允许.匹配所有字符 NSRegularExpressionAnchorsMatchLines = 1 \u0026lt;\u0026lt; 4, // 允许^,$匹配每一行的开头和结尾 NSRegularExpressionUseUnixLineSeparators = 1 \u0026lt;\u0026lt; 5, // 只把\\n识别为换行符 NSRegularExpressionUseUnicodeWordBoundaries = 1 \u0026lt;\u0026lt; 6 // 使用 Unicode TR#29 规定的边界，否则，使用传统的正则表达式的词边界 }; 关于NSRegularExpression还有一些其他的可以使用方法们，具体可以查看这里。\n一些常用的正则： 邮箱：^[a-zA-Z0-9]{4,}@[a-z0-9A-Z]{2,}\\\\.[a-zA-Z]{2,}$ 手机号码：^((13[0-9])|(15[^4\\\\D])|(18[0,2,5-9]))\\\\d{8}$ 大陆固定电话号码：^\\\\d{4}-|\\\\d{3}-)?(\\\\d{8}|\\\\d{7}$ 身份证号：\\\\d{14}[[0-9],0-9xX] Email地址：^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\.\\\\w+([-.]\\\\w+)*$ 纯数字：^[0-9]*$ 由数字和英文字母组成：^[A-Za-z0-9]+$ QQ号：^[1-9][0-9]\\{4,\\}$ 中国邮政编码：^[1-9]\\\\d{5}(?!\\\\d)$ URL：^http(s)?://([\\\\w-]+\\\\.)+[\\\\w-]+(/[\\\\w- ./?%\u0026amp;=]*)?$ 纯汉字：^[\\u4e00-\\u9fa5]{0,}$ ","date":"2016-09-26T23:41:42Z","permalink":"https://lisongrc.github.io/p/20160923aaaabf/","title":"系统地学习正则表达式(二)：进阶篇"},{"content":"什么是正则表达式 正则表达式就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，用来表达对字符串的一种过滤逻辑。\n通过正则表达式可以达到如下的目的：\n给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）； 可以通过正则表达式，从字符串中获取我们想要的特定部分。 为了让大家更方便地学习，先推荐一个验证正则表达式的软件Regextor，具体可以看我的这篇文章，里面还推荐了很多Mac上的好软件。\n下面开始讲解正则表达式各种规则：\n匹配普通文本字符 正则表达式可以只包含普通的文本，代表去精确匹配这个文本。例如:\n正则表达式：song 待匹配文本：xiaosongge，xiaoSongge 匹配后结果：xiaosongge，xiaoSongge\n正则表达式默认是区分大小写的，所以song不会匹配 \u0026ldquo;Song\u0026rdquo; 。但是大部分的正则表达式实现都提供了一个选项表示不区分大小写。\n匹配任意字符 .用来匹配一个任意字符，例如：\n正则表达式：c.t 待匹配文本：cat cet caaat dog 匹配后结果：cat cet caaat dog\n分析：c.t会匹配以\u0026quot; c \u0026ldquo;开头，以\u0026rdquo; t \u0026ldquo;结尾，中间为任意字符的字符串。\n同理，多个连续的.可以匹配多个连续的任意字符：\n正则表达式：c..t 待匹配文本：cat cet caat dog 匹配后结果：cat cet caat dog\n匹配特殊字符 .在正则表达式中含有特殊的意义，是一个特殊的字符。\\ 也是特殊字符，可以对特殊字符起到转义作用。如果你想匹配的是一个真正的\u0026rdquo; . \u0026ldquo;字符，需要在.前面加上\\ 对字符进行转义。所以，\\.表示真正的\u0026rdquo; . \u0026ldquo;字符。\n正则表达式：c\\.t 待匹配文本：cat c.t dog 匹配后结果：cat c.t dog\n注意：因为\\ 也是特殊字符，所以想要匹配一个真正的\u0026rdquo; \\ \u0026ldquo;字符，需要使用两个反斜线\\\\\\\\ ：\n正则表达式：c\\\\\\t 待匹配文本：cat c\\t dog 匹配后结果：cat c\\t dog\n使用字符集合 上面说到.能匹配一个任意字符，但是如果我想匹配几个特定字符怎么办？匹配一组特定的字符可以使用[和]元字符。\n正则表达式：c[ab]t 待匹配文本：cat cbt cet 匹配后结果：cat cbt cet\n分析：[ab]会匹配\u0026rdquo; a \u0026ldquo;或者\u0026rdquo; b \u0026ldquo;。所以c[ab]t会匹配\u0026rdquo; cat \u0026ldquo;和\u0026rdquo; cbt \u0026ldquo;而不会匹配\u0026rdquo; cet \u0026ldquo;。\n使用字符组区间 在上面的例子中，假如我想匹配cet怎么办，在[]里面多加一个吗？那如果我想匹配任意小写字母呢，往里面写几十个吗？虽然是可以的，但是太长了。这里我们可以用到[a-z]：\n正则表达式：c[a-z]t 待匹配文本：cat cbt czt c2t 匹配后结果：cat cbt czt c2t\n分析：c[a-z]t表示以\u0026rdquo; c \u0026ldquo;开头，\u0026rdquo; t \u0026ldquo;结尾，中间为字母 \u0026quot; a \u0026quot; - \u0026quot; z \u0026quot; 的任意一个字母。\n类似的区间还有：\n[0-9] 和[0123456789]的功能一样。匹配所有的数字。 [A-F] 匹配A到F的大写字符。 [A-Z] 匹配所有的 A 到 Z 的大写字符。 [a-z] 匹配所有的 a 到 z 的小写字符。 [A-z] 匹配从 ASCII A 到 ASCII z 的所有字符（不仅仅匹配所有字母，还匹配在 ASCII 表中 A 到 z 中的字符，如 [ 和 ^ 等）。 [A-Za-z0-9] 匹配所有的大小写字母和数字。 非字符集的匹配 字符集合一般用于指定一组需要匹配的字符。但是有些时候，你想要排除一组你不想匹配的字符。可以通过对于字符集合的否定来实现。例如：\n正则表达式：c[^a-z]t 待匹配文本：cat cbt czt c2t cAt 匹配后结果：cat cbt czt c2t cAt\n分析：这个和前面一个例子完全相反。[a-z] 匹配所有的小写字母，而 [^a-z] 匹配所有的不是小写字母的字符。\n注意，^字符是将字符集合中的所有字符都取消匹配。\n元字符 元字符在正则表达式中有特殊的意义，上面我们已经说了几个元字符，比如.、[和]。这些字符不能直接表示自己的含义，例如，不能直接使用[来匹配\u0026rdquo; [ \u0026ldquo;，使用.来匹配\u0026rdquo; . \u0026ldquo;。\n所有的元字符都可以在前面加上反斜线转义，当转义后，字符将匹配自身而不是其特殊含义。例如，\\[将匹配\u0026rdquo; [ \u0026ldquo;:\n正则表达式：a\\[b 待匹配文本：a[b ab a[[b 匹配后结果：a[b ab a[[b\n注意：\\ 用来转义元字符，这也意味着\\ 也是一个元字符。所以如果需要匹配真正的\u0026rdquo; \\ \u0026ldquo;，可以使用\\\\\\ ：\n正则表达式：a\\\\\\b 待匹配文本：a\\b a\\b a[[b 匹配后结果：a\\b a\\b a[[b\n空白字符 有时候你可能需要匹配文本中不能打印的空白字符。例如，你希望能够找到所有的 Tab 字符，或者是所有的换行符。你可以使用下表中的特殊元字符：\n元字符 描述 [\\b] 退格符 \\f 换页符 \\n 换行 \\r 回车 \\t 制表符 \\v 垂直制表符 例如\\r\\n将匹配一个回车换行组合，在 Windows 中表示一个文件换行。在 Linux 和 Unix 系统中，只需要使用\\n即可。\n匹配特定的字符类型 有一些特殊的元字符可以用来匹配常用的字符集合。这些元字符被称为匹配字符类。你会发现使用它们是很方便的。\n匹配数字或者非数字 上面说到，[0-9] 可以匹配所有的数字。如果不想匹配任何数字，则可以使用[^0-9]。下表中列出了数字和非数字的类元字符：\n元字符 | 描述\n| - \\d | 任何数字 (同 [0-9]) \\D | 任何非数字 (同 [^0-9]) 正则表达式：c\\dt 待匹配文本：cat c2t czt c9t 匹配后结果：cat c2t czt c9t\n正则表达式：c\\Dt 待匹配文本：cat c2t czt c9t 匹配后结果：cat c2t czt c9t\n匹配字母字符和非字母字符 另外一个常用的类元字符是\\w和\\W：\n元字符 描述 \\w 所有的文字数字式字符：大小写字母、数字和下划线 (同 [a-zA-Z0-9_]) \\W (同 [^a-zA-Z0-9_]) 正则表达式：c\\wt 待匹配文本：cat c2t czt c-t c\\t 匹配后结果：cat c2t c-t c\\t\n正则表达式：c\\Wt 待匹配文本：cat c2t c-t c\\t 匹配后结果：cat c2t c-t c\\t\n匹配空白和非空白 最后一个将要遇到的匹配类是空白类：\n元字符 | 描述\n| - \\s | 所有的空白字符 (同 [\\f\\n\\r\\t\\v]) \\S | 所有的非空白字符 (同 [^\\f\\n\\r\\t\\v]) 正则表达式：c\\st 待匹配文本：cat c t c2t c\\t 匹配后结果：cat c t c2t c\\t\n正则表达式：c\\St 待匹配文本：cat c t c2t c\\t 匹配后结果：cat c t c2t c\\t\n匹配一个或者更多字符 +元字符表示匹配一个或者多个字符。例如，a将匹配\u0026quot;a\u0026rdquo;，而a+则匹配一个或者多个\u0026quot;a\u0026quot;。\n正则表达式：cat 待匹配文本：ct cat caat caaat 匹配后结果：ct cat caat caaat\n正则表达式：ca+t 待匹配文本：ct cat caat caaat 匹配后结果：ct cat caat caaat\n当在字符集合上使用+的时候，需要将+符号放在集合外面：\n正则表达式：c[0-9]+t 待匹配文本：ct c0t cat c123t 匹配后结果：ct c0t cat c123t\n分析：c[0-9]+t表示以\u0026quot; c \u0026ldquo;开头，以\u0026rdquo; t \u0026ldquo;结尾，中间为一个或多个数字的字符串。\n当然，[0-9+]也是一个合法的正则表达式，但它表示一个包含 \u0026quot; 0 \u0026quot; - \u0026quot; 9 \u0026quot; 和 \u0026quot; + \u0026quot; 符号的字符集合。\n一般的，元字符如.和+等用于字符集合的时候是作为字面含义使用的，因此没有必要转义。但是对其进行转义也没错，所以，[0-9+]和[0-9\\+]的功能是一样的。\n注意：+是一个元字符，匹配\u0026rdquo;+\u0026ldquo;需要使用转义\\+。\n匹配零个或者更多字符 如果希望匹配零个或更多字符的时候，可以使用*元字符。\n正则表达式：ca*t 待匹配文本：ct cat caat cbt 匹配后结果：ct cat caat cbt\n注意：*符号是元字符。为了能够匹配\u0026rdquo; * \u0026ldquo;，需要进行转义\\*。\n匹配零个或者一个字符 ?匹配零个或者一个字符。所以，?非常适合于在文本中匹配一个可选的字符。\n正则表达式：ca?t 待匹配文本：ct cat caat cbt 匹配后结果：ct cat caat cbt\n注意：?符号是元字符。为了能够匹配\u0026rdquo; ? \u0026ldquo;，需要进行转义\\?。\n使用匹配次数 正则表达式允许指定匹配的次数。次数可以在“ { ”和“ } ”之间指定。 注意：{和}也是元字符，在使用字面含义的时候需要转义。\n精确次数匹配 为了指定匹配的次数，你可以在{和}之间输入数字。例如，{3}将匹配 3 次前面出现的字符或集合：\n正则表达式：ca{3}t 待匹配文本：ct cat caaat cbt 匹配后结果：ct cat caaat cbt\n至少次数匹配 我们也可以只指定匹配的最小值。例如， {2,}意味着匹配 2次或者更多次：\n正则表达式：ca{1,}t 待匹配文本：ct cat caaat cbt 匹配后结果：ct cat caaat cbt\n次数区间匹配 我们还可以使用最小值和最大值来确定匹配的数量。例如，{2,3}意味着最少匹配 2次，最多匹配3次。 正则表达式：ca{2,3}t 待匹配文本：ct cat caaat cbt 匹配后结果：ct cat caaat cbt\n所以?和{0,1}的功能是一样的，+和 {1,}的作用是一样的。\n非贪婪匹配 先看看下面的例子：\n正则表达式：s.*g 待匹配文本：xiao song xiao song 匹配后结果：xiao song xiao song\n分析：s.*g并没像预想中的匹配两个\u0026rdquo; song \u0026ldquo;，而是匹配了第一个\u0026rdquo; s \u0026ldquo;和最后一个 \u0026quot; g \u0026ldquo;之间的所有文本。\n这是因为*和+都是贪婪匹配。也就是说，正则表达式总是寻找最大的匹配，而不是最小的，这是故意设计的。\n但是如果你不希望贪婪匹配的时候就要使用这些量词的非贪婪匹配（匹配尽可能少的字符）。非贪婪量词是在量词后面加上?：\n贪婪量词 | 非贪婪量词\n| - | *? |+? {n,} | {n,}? *?是*的非贪婪版本，所以可以使用*?来修改上面的例子：\n正则表达式：s.*?g 待匹配文本：xiao song xiao song 匹配后结果：xiao song xiao song\n分析：可以看到s.*?g匹配到了两个\u0026rdquo; song \u0026ldquo;。\n定义字符串边界 字符串边界匹配的元字符是^和$，分别用于字符串的开始和结束。\n^用法如下：\n正则表达式：^xiao\n待匹配文本：xiaosong 匹配后结果：xiaosong\n待匹配文本：axiaosong 匹配后结果：axiaosong\n分析：^xiao匹配以\u0026rdquo; xiao \u0026ldquo;开头的字符串。\n$用法如下：\n正则表达式：song$\n待匹配文本：xiaosong 匹配后结果：xiaosong\n待匹配文本：xiaosonga 匹配后结果：xiaosonga\n分析：song$匹配以\u0026quot;song \u0026ldquo;结尾的字符串。\n共同使用：\n正则表达式：^[0-9a-zA-Z]{4,}$\n待匹配文本：a1b234ABC 匹配后结果：a1b234ABC\n待匹配文本：+a1b23=4ABC 匹配后结果：+a1b23=4ABC\n分析：^[0-9a-zA-Z]{4,}$匹配用数字或者字母组成的，并且位数大于等于四位的字符串。\n注意：^如果位于集合开始处的话，则表示否定；如果在集合外面，则将匹配字符串的开始位置。大家可以试试[^0-9]和^[0-9]的区别。\n使用多行模式 但是(?m)可以启用多行模式。在多行模式下，正则表达式引擎将换行符作为字符串的分隔符，^将匹配文本的开始或者一行的开始，而$则可以匹配文本的结束或者是一行的结尾处。\n修改下上个例子：\n正则表达式：(?m)^[0-9a-zA-Z]{4,}$\n待匹配文本：a1b234ABC +a1b23=4ABC ABC123456\n匹配后结果：a1b234ABC +a1b23=4ABC ABC123456\n分析：(?m)^[0-9a-zA-Z]{4,}$会去匹配每行用数字或者字母组成的，并且位数大于等于四位的字符串。\n注意：如果使用多行模式的话，(?m)必须放置在正则表达式的开始。 (?m)在大部分的正则表达式实现中并不支持。有些正则表达式实现还支持使用\\A匹配字符串的开始，\\Z匹配字符串的结束。如果支持的话，则这些元字符的功能和^、$是一样的。但是这些元字符不能使用(?m)修饰，所以也不能用于多行模式。\n","date":"2016-09-13T19:13:44Z","permalink":"https://lisongrc.github.io/p/201609835121d0/","title":"系统地学习正则表达式(一)：基础篇"},{"content":"为什么要格式化代码 当团队内有多人开发的时候，每个人写的代码格式都有自己的喜好，也可能会忙着写代码而忽略了格式的问题。 在之前，我们可能会写完代码后，再一点一点去调格式，很浪费时间。\n有了ClangFormat插件后，就可以一键把代码格式化成统一的样式，不仅节省了时间，也使得代码更规范。我们还可以定制自己喜欢的样式。\n安装ClangFormat插件 可以手动安装(下载GitHub项目编译)，也可以用Alcatraz(插件管理器)安装，都很简单，具体可以看我的文章《Xcode方便开发的插件推荐》。\n装好后是下图这样的，我们可以看到它内置了LLVM、Google、Chromium、Mozilla、WebKit五种样式。 使用方法 通过菜单可以看到，它可以格式化选中的文字们，或者格式化选择的文件们。下面演示下LLVM样式下的格式化： 使用自定义样式 1、需要先把上面菜单里面的File选中，因为我们需要让它用我们自己写的配置文件。 2、在工程目录下创建配置文件.clang-format文件并编辑。.clang-format文件用的是YAML格式:里面要用的字段在后面会详细解释。\nkey1: value1 # 一个注释 key2: value2 当然如果你已经有.clang-format文件的话，直接拖动到项目根目录也可以。 文章结尾有我在用的.clang-format文件。\n温馨提示：.clang-format文件是隐藏文件，默认是看不见的。需要在终端输入以下命令：\n//显示 隐藏文件 defaults write com.apple.finder AppleShowAllFiles -bool true killall Finder //隐藏 隐藏文件 defaults write com.apple.finder AppleShowAllFiles -bool false killall Finder 全局配置 上面我们是在项目根目录创建的.clang-format文件，每次建新项目都要有。如果你想让所有的项目公用一个文件，把.clang-format文件放在所有项目都在的一个最大根目录下就可以了。\n###让一段代码不受格式化影响 如果想让一段代码不受格式化影响，需要将他们包含在// clang-format off 和 // clang-format on这两句注释之间，这样这段代码就不会被格式化，但是这两句注释本身是会被格式化的。 设置快捷键 首先你可以选中菜单中的 Enable Format On Sava，把它点Disable Format On Sava，这样以后每次按⌘+S保存文件时就可以自动格式化了。 我们也可以给一些菜单设置快捷键，使用的时候不用每次去选择各级菜单了。比如我们给Format Selected Text设置快捷键： 你也可以为其他菜单设置快捷键，其实呢，我用Format Selected Text的时候很少，每次都是想格式化的时候直接⌘+S就行了哈哈哈。\n配置文件中属性的含义讲解 下面说一些配置文件的常用的参数介绍，其他的可以看官方文档：Clang-Format Style Options，其中小括号内代表他需的是什么类型的值。\nBasedOnStyle (string) 基于哪种样式。除了文件中写出的定制属性外，别的没定制的属性都默认用这种样式的。 可选值有五种： LLVM：一种遵循LLVM coding standards的样式。 Google：一种遵循Google’s C++ style guide的样式。 Chromium：一种遵循Chromium’s style guide的样式。 Mozilla：一种遵循Mozilla’s style guide的样式。 WebKit：一种遵循WebKit’s style guide的样式。\nAccessModifierOffset (int) 访问修饰词 (比如public) 前面额外需要加的缩进长度。默认为0。\nAlignConsecutiveAssignments (bool) 如果是true，把连续的赋值操作按=对齐，默认为false。 AlignConsecutiveDeclarations (bool) 如果是true，把连续行的变量名对齐。默认为false。 AlignTrailingComments (bool) 如果是true，对齐尾部注释。默认为false。 AllowShortCaseLabelsOnASingleLine (bool) 如果是true, 允许一个case在一行写完，默认为false。 BreakBeforeBraces (string) 大括号前面是否换行，具体可选值看文档。一般用Allman，代表所有大括号都换行。 ColumnLimit (unsigned) 每行最多多少个字符，0不限制\nIndentWidth (unsigned) 缩进宽度，默认为2，但是我们一般设置为4。 IndentCaseLabels (bool) switch的case缩进宽度，一般用true。默认为false，case会和switch对齐。\nKeepEmptyLinesAtTheStartOfBlocks (bool) 是否保留block里面开始的空行们。默认为true。\nMaxEmptyLinesToKeep (unsigned) 最多可以有连续几行空行，默认为1。 ObjCBlockIndentWidth OC的block里面的缩进宽度，默认为4。\nObjCSpaceAfterProperty (bool) OC里面，是否在@property后加空格。默认为false。 ObjCSpaceBeforeProtocolList (bool) OC里面，是否在Protocol名字列表前面加空格，默认为true。 PointerAlignment (string) 指针的位置。默认为Right。 可选值： Left：NSString* name Middle：NSString * name Right：NSString *name\nSpaceBeforeAssignmentOperators (bool) = 前面是否有空格。默认为true。\nSpaceBeforeParens (string) 是否在(前面加空格。默认ControlStatements。 可选值： Never: 从来不在(前面加空格。 ControlStatements:在控制语句(for/if/while\u0026hellip;)的(前面加空格。 Always:总会在(前面加空格。\nSpaceInEmptyParentheses (bool) 是否在()里面插入一个空格。默认false。\nSpacesBeforeTrailingComments (unsigned) 在尾部//注释前面加几个空格。 SpacesInAngles (bool) 是否在\u0026lt;后边和\u0026gt;前边插入空格，默认为false。 SpacesInContainerLiterals (bool) @[]里面，是否在 [ 后和 ] 前加空格。默认为true。 SpacesInParentheses (bool) 是否在(后面和)前面加空格，默认为false。 当项目里面有多种语言时，我们可以分别设置样式：\n--- # 我们默认用 LLVM 样式, 缩进宽度为4。 BasedOnStyle: LLVM IndentWidth: 4 --- Language: Cpp # C++ 设置星号左对齐。 PointerAlignment: Left --- Language: JavaScript # JavaScript 每行字符限制设置为100。 ColumnLimit: 100 --- Language: Proto # 不格式化Proto文件。 DisableFormat: true ... 这个是我在用的.clang-format文件。大家可以下载下来自己修改一下再用。\n","date":"2016-09-10T21:44:04Z","permalink":"https://lisongrc.github.io/p/2016099de00e69/","title":"超详细的Xcode代码格式化教程，可自定义样式"},{"content":"什么是CocoaPods？ CocoaPods是专门为iOS工程提供对第三方库的依赖的管理工具，通过CocoaPods，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置。直观、集中和自动化地管理我们项目的第三方库。\n我们都有这样的经历，当我们添加第三方库的时候，需要导入一堆相关依赖库，更新的时候也要删掉重新导入然后再配置。当我们需要更新某个第三方库的时候，我们又要手动移除该库，导入新的库，然后再配置。这些是很麻烦且没有意义的工作。\n当我们开始使用CocoaPods管理第三方库后，我们只需要相当少的配置，其它的一切都交由CocoaPods来管理即可，我们使用起来就更省心了。\n安装CocoaPods 1.首先更新gem到最新版本，在终端中输入：$ sudo gem update --system,注意不要把“$”复制上。等待一会儿会看到： 2.删除自带的ruby镜像，终端输入：gem sources --remove https://rubygems.org/。 3.添加淘宝的镜像，终端输入：gem sources -a https://gems.ruby-china.org/(原来的淘宝镜像 https://ruby.taobao.org/已经不能用了)。 4.可以用gem sources -l 来检查使用替换镜像位置成功，结果应该只有 https://gems.ruby-china.org/ 才对。 5.安装CocoaPods，终端输入：sudo gem install cocoapods。 等待一会儿会看到： 6.然后配置下CocoaPods，终端输入：pod setup。 等待过程可能有点长，成功后会看到： 到这里CocoaPods就安装好了。\n查找第三方库 比如查找MJExtension，终端输入：pod search MJExtension，第一次搜索他需要建索引，等待一会儿就可以了。 完成后他会自动进入一个新的页面显示搜索结果，上下滑动查看更多，要退出的话按wq就可以了。以后再搜索就不需要建索引了。 引入第三方库到项目中 我先在桌面上新建一个Test项目，然后演示把MJExtension导进去。 刚开始的文件目录是这样的 1,首先打开终端，cd到Test路径下。 2.然后生成并编辑一个Podfile文件，命令为vim Podfile，要导入的第三方都要在这里面写上。进去后需要先按I键进入编辑状态，写完后按esc，然后按shift+zz(或者先按shift+:,再按wq)就可以保存退出了。下面的动图里面都有。 Podfile的格式大概如下，其中\u0026rsquo;Test\u0026rsquo;为你的target的名字。\nplatform :ios,\u0026#39;8.0\u0026#39; target \u0026#39;Test\u0026#39; do pod \u0026#39;MJExtension\u0026#39;, \u0026#39;~\u0026gt; 3.0.13\u0026#39; end 3.安装，命令为：pod install`。 安装成功之后，就可以去项目里面使用了。现在的项目文件变成了这样 之前我们一直是双击Test.xcodeproj打开项目，以后我们就要双击Test.xcworkspace打开了，打开后发现项目里面多了红色框的部分，可以看到MJExtension已经被引入了。 使用第三方 你会发现当引入MJExtension的头文件时，可以#import \u0026lt;MJExtension.h\u0026gt;或者#import \u0026lt;MJExtension/MJExtension.h\u0026gt;，但是却不能在输入#import \u0026quot;MJExtension.h\u0026quot;的时候出现提示。虽然强制输入也可以编译通过，但是感觉很不爽。 解决这个问题的办法是在工程的Build Settings搜索Search，然后在User header search paths中添加$(SRCROOT)并选择recursive。 现在就可以提示#import \u0026ldquo;MJExtension.h\u0026quot;啦。 然后我们就可以在项目里面使用MJExtension的方法啦。 增加新的第三方 如果使用过程中我还想添加其他的第三方怎么办，只要在Podfile里面接着添加，然后终端再执行pod install就可以了。 更新CocoaPods中的第三方们。 第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令pod update就可以了。\n如果遇到pod install或者pod update慢的问题，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： pod install --verbose --no-repo-update pod update --verbose --no-repo-update\n删除CocoaPods中的某些第三方们。 当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行pod update或者pod install就可以了。\n将CocoaPods从项目中删除 如果你在以后的使用过程中不想用CocoaPods了怎么办？很简单，把多出来的东西们都删掉就可以了，不过为了项目正常运行，你需要手动导入已经使用的第三方们哦。 升级CocoaPods 升级CocoaPods版本的命令和安装CocoaPods的命令一样，都是sudo gem install cocoapods。 如果老版本升级cocoapods的时候提示Operation not permitted - /usr/bin/xcodeproj，改用命令sudo gem install -n /usr/local/bin cocoapods --pre就可以了。\n卸载CocoaPods 卸载CocoaPods的命令是sudo gem uninstall cocoapods 执行完命令后，最下面打印Successfully uninstalled cocoapods字样就代表已经成功卸载了。\nCocoaPods Mac App的安装和使用 CocoaPods桌面应用版下载地址：https://cocoapods.org/app 打开应用会提示你是否安装命令行工具，选择install就也可以在命令行使用Pod了。省去了上面的步骤们，方便快捷的使用CocoaPods。 现在假如要给一个Test项目加入第三方库 1.选择File-New Podfile from Xcode Project，去选择项目的Project文件。 2.填写自动生成的Podfile，并且安装。 然后就可以去打开工程了，是不是比命令行简单多了。 注意：Cocoapods.app 删掉并执行命令可能会报错：Unable to locate the CocoaPods.app application bundle. Please ensure the application is available and launch it at least once 这时候只要执行sudo gem install -n /usr/local/bin cocoapods命令就可以了。\nCocoaPods官方使用指南 链接：https://guides.cocoapods.org/ 有什么不了解的或者遇到错误可以去这里查看一下。\nXCode的CocoaPods插件 CocoaPods-xcode-plugin是一个XCode的插件，可以很方便的在Xcode通过pods安装各种第三方库。前提是终端已经安装好CocoaPods，使用方法大概如下： ","date":"2016-09-08T00:47:54Z","permalink":"https://lisongrc.github.io/p/201609750b7a66/","title":"看一遍就会的CocoaPods的安装和使用教程"},{"content":"有时候我们需要处理图片，比如改变大小，旋转，截取等等，所以今天说一说图片处理相关的一些操作。 本文所说的方法都是写在UIImage的Category中，这样使用起来也方便；由于代码太多，这里就不贴具体实现代码了，大家可以去我的Github查看demo，效果如下：\n颜色相关 1.根据颜色生成纯色图片 就是根据制定的颜色生成一张纯色的图片\n+ (UIImage *)imageWithColor:(UIColor *)color; 使用方法，比如设置UIImageView的图片为红色纯图片：\nself.imageView.image = [UIImage imageWithColor:[UIColor redColor]]; 2.取图片上某一像素的颜色 有时候我们需要获取图片上的某一点的颜色，比如画板应用选择画笔颜色的时候，其实是在一张有所有颜色的图片上点击选择实现的。 需要注意的是这里要传的参数point是相对于图片上的点。\n- (UIColor *)colorAtPixel:(CGPoint)point; 使用方法，比如我们在图片上加个tap手势，然后在响应方法里面这样写就可以了：\n- (void)handleTap:(UITapGestureRecognizer *)tap { CGPoint point = [tap locationInView:tap.view]; UIImage *image = self.imageView.image; CGPoint pointInImage = CGPointMake(point.x * image.size.width / self.imageView.frame.size.width, point.y * image.size.height / self.imageView.frame.size.height); self.view.backgroundColor = [image colorAtPixel:pointInImage]; } **3.获得灰度图 ** 获取一张彩色图片的黑白图片\n- (UIImage *)convertToGrayImage; 使用方法：\nself.imageView.image = [image convertToGrayImage]; 旋转相关 1.纠正图片的方向 当我们需要读取相册的图片，发现相册里面的方向和展示出来的图片的方向不一样，这时候就要矫正方向了。\n- (UIImage *)fixOrientation; 使用:\nself.imageView.image = [image fixOrientation]; 2.按给定的方向旋转图片 在做图片处理工具的时候，我们可能需要旋转图片。 这个方法的参数是系统枚举UIImageOrientation。\ntypedef NS_ENUM(NSInteger, UIImageOrientation) { UIImageOrientationUp, // default orientation UIImageOrientationDown, // 180 deg rotation UIImageOrientationLeft, // 90 deg CCW UIImageOrientationRight, // 90 deg CW UIImageOrientationUpMirrored, // as above but image mirrored along other axis. horizontal flip UIImageOrientationDownMirrored, // horizontal flip UIImageOrientationLeftMirrored, // vertical flip UIImageOrientationRightMirrored, // vertical flip }; - (UIImage*)rotate:(UIImageOrientation)orient; 使用，比如顺时针旋转180度：\nself.imageView.image = [image rotate:UIImageOrientationDown]; 3.垂直翻转 其实就是上面的方法传UIImageOrientationDownMirrored参数。\n- (UIImage *)flipVertical; 4.水平翻转 其实就是传UIImageOrientationUpMirrored参数。\n- (UIImage *)flipHorizontal; 5.将图片旋转degrees角度 传入一个自定义的角度。\n- (UIImage *)imageRotatedByDegrees:(CGFloat)degrees; 6.将图片旋转radians弧度\n- (UIImage *)imageRotatedByRadians:(CGFloat)radians; 生成图相关 1.截取image对象rect区域内的图像\n- (UIImage *)subImageWithRect:(CGRect)rect; 2.压缩图片至指定尺寸\n- (UIImage *)rescaleImageToSize:(CGSize)size; 3.压缩图片至指定像素\n- (UIImage *)rescaleImageToPX:(CGFloat )toPX; 4.生成一个size大小的平铺图片\n- (UIImage *)getTiledImageWithSize:(CGSize)size; 5..UIView转化为UIImage\n+ (UIImage *)imageFromView:(UIView *)view; 6.将两个图片生成一张图片 firstImage在下面，secondImage在上面\n+ (UIImage*)mergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage; Gif相关 将一个Gif直接设置为UIImageView的image就可以显示动态图了。\n/** 用一个Gif生成UIImage，传入一个GIFData */ + (UIImage *)animatedImageWithAnimatedGIFData:(NSData *)theData; /** 用一个Gif生成UIImage，传入一个GIF路径 */ + (UIImage *)animatedImageWithAnimatedGIFURL:(NSURL *)theURL; 使用：\nNSString *path = [[NSBundle mainBundle] pathForResource:@\u0026#34;gif\u0026#34; ofType:@\u0026#34;gif\u0026#34;]; self.imageView.image = [UIImage animatedImageWithAnimatedGIFURL:[NSURL fileURLWithPath:path]]; //或者 self.imageView.image = [UIImage animatedImageWithAnimatedGIFData:[NSData dataWithContentsOfFile:path]]; 希望能帮到大家，持续更新中。\n","date":"2016-09-04T20:37:30Z","permalink":"https://lisongrc.github.io/p/2016095d76ea11/","title":"UIImage图片处理，旋转、截取、平铺、缩放等操作，持续更新中"},{"content":"Xcode的插件可以使我们开发更方便，效率更高。你没有理由拒绝哈哈，下面推荐一些插件：\nAlcatraz https://github.com/alcatraz/Alcatraz Alcatraz 是一个帮你管理 Xcode 插件、模版以及颜色配置的工具。它可以直接集成到 Xcode 的图形界面中，让你感觉就像在使用 Xcode 自带的功能一样。 使用方法推荐巧哥的这篇文章： http://blog.devtang.com/2014/03/05/use-alcatraz-to-manage-xcode-plugins/ 下面的这些插件都带有链接地址，安装方法可以使用Alcatraz，也可以在GitHub把工程下载下来，编译一遍，然后完全退出Xcode，重启Xcode，如果弹出选择菜单就选择Load Bundle.\nKSImageNamed 一款方便填写图片文件名称的插件。支持NSImage和UIImage，当你写到[UIImage imaged:的时候，插件会把项目中的图片名称提示出来，并且还有预览功能，对经常用代码生成图片视图的童鞋十分方便。 FuzzyAutocomplete https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin 强大的模糊匹配输入 让你写代码的时候再也不用费脑子去记住名字那么长的对象或者函数名了 好用到让你想哭，但是Xcode8出来后应该就不用了吧。 FKConsole https://github.com/Forkong/FKConsole 在控制台直接将UTF8编码转化为中文! ESTranslate https://github.com/EnjoySR/ESTranslate-Xcode 快速翻译Xcode中代码单词以及句子! VVDocumenter https://github.com/onevcat/VVDocumenter-Xcode 喵大的又一力作 能够识别当前函数的参数和返回类型 帮助你快速编写符合规范的注释(目前是以Javadoc为标准) RSImageOptimPlugin https://github.com/yeahdongcn/RSImageOptimPlugin 可使用 ImageOptim 对项目里的图片资源进行优化，减少安装包的体积。 deriveddata https://github.com/kattrali/deriveddata-exterminator 如果你老是遇到Xcode抽风，显示一些编译的错误或警告，或者有些时候Xcode会出各种奇怪的问题，但是编译又能通过，清除Xcode缓存就可以解决这类问题。 HOStringSense https://github.com/holtwick/HOStringSense-for-Xcode 在编辑字符串的时候，它会在代码上方生成一个字数统计的提示框。当你需要编辑多行文本时，可以在弹出的文本框中编辑字符串内容，插件会自动进行字符转义的工作，并实时在代码中更新。 OMColorSense https://github.com/omz/ColorSense-for-Xcode 一个简洁的可视化颜色插件。在你编辑颜色的RGB值的时候，会在代码上方出现一个小的色块，显示对应的颜色。点击色块还会弹出一个颜色编辑器，在编辑器中得到的色值会自动填入colorWithRed:green:blue:alpha:方法中，贴心！ SCXcodeSwitchExpander https://github.com/stefanceriu/SCXcodeSwitchExpander Switch语句相当繁琐。虽然它清楚地列出了在每种情况下应该处理的方式，但一个个填入枚举值那真是浪费时间。SCXcodeSwitchExpander插件可以帮我们完成这个工作，它可以自动获得所有的枚举值填入相应的位置，而我们只需在每个枚举值下面填入对应的逻辑即可，方便极了！ XcodeBoost https://github.com/fortinmike/XcodeBoost 通过配置，我们可以使用光标或者不精确的选择就可以剪切或者拷贝代码行，可以在粘贴代码的时候不触发代码格式化，还可以通过在.m文件中拷贝方法，粘贴进.h文件的时候就可以得到自动格式成的方法声明，还有好些功能都可以实现。 Xcode-Quick-Localization https://github.com/tappollo/Xcode-Quick-Localization 你是否已经厌倦了反复写NSLocalizedString？如果是，那么QuickLocalization插件可以助你一臂之力。当你在编辑字符串的时候，只需要按下option+shift+d，就可以将@“Any String”转换成NSLocalizedString(@\u0026ldquo;Any String\u0026rdquo;, nil)。而且还可以通过修改配置来定义要出现在comment字段中的内容。 XAlign https://github.com/qfish/XAlign 一个格式化代码的插件，作为有洁癖的码农 看到不对齐的代码一定是不能忍的 XAlign可以轻松解决你的烦恼。 ClangFormat https://github.com/travisjeffery/ClangFormat-Xcode ClangFormat也是一款格式化代码的插件，开发者不仅可以实现对代码的自动或批量格式化，还可以进行自定义配置。 CodePilot https://github.com/macoscope/CodePilot 你要找的是文件？是文件夹？是代码？Never Mind，CMD+SHIFT+X调出CodePilot，输入任何你想到搜的东西吧！想搜appFinishLaunchingWithOptions？忘记咋拼了？没关系强大的代码搜索能力，appflaun一样也可以找到！超级强大的正则匹配，匹配任何你所想！ CocoaPods https://github.com/CocoaPods/CocoaPods 可以很方便的在Xcode通过pods安装各种第三方库。关于CocoaPods的使用请看这篇文章。 RTImageAssets https://github.com/rickytan/RTImageAssets 用来生成 @3x 的图片资源对应的 @2x 和 @1x 版本，只要拖拽高清图到 @3x 的位置上，然后按 Ctrl+Shift+A 即可自动生成两张低清的补全空位。当然，如果你对图片质量要求不高的话，你也可以从 @2x 的图生成 @3x 版本。 JKBlockCommenter https://github.com/Johnykutty/JKBlockCommenter 选中一段代码，按下⌘⌥/就可把这段代码包含在/**/之间，方便注释。 Auto-Importer https://github.com/citrusbyte/Auto-Importer-for-Xcode 可以搜索和自动导入头文件的一款Xcode插件。 ZLGotoSandboxPlugin https://github.com/MakeZL/ZLGotoSandboxPlugin 一个看应用沙盒的插件。也可以用SimPholders，看 这篇文章 FKRealGroup https://github.com/Forkong/FKRealGroup FKRealGroup是文件夹创建删除增强插件，会在编辑菜单中添加”New Real Group”和”Delete Real Group”两个选项。 Xcode本身的”New Group”选项只会创建一个虚拟文件夹，并不会在本地磁盘创建真实文件夹。 FKRealGroup可以解决这个问题。”New Real Group”选项会在相应磁盘目录创建一个真实的文件夹。 我们在Xcode中如果使用”Delete”选项去删除文件夹，如果此文件夹为真实文件夹，那么一般情况下，Xcode只会删除此真实文件夹内的文件，而文件夹却依然存在。 ”Delete Real Group”可以解决这个问题。”Delete Real Group”会默认删除真实文件夹，移动到废纸篓里面。 ActivatePowerMode https://github.com/poboke/ActivatePowerMode 一个装逼插件，打字的时候有一些特效。 持续更新中……。\n","date":"2016-08-26T17:40:39Z","permalink":"https://lisongrc.github.io/p/2016087d8ef64b/","title":"Xcode方便开发的插件推荐"},{"content":"在这里总结一些iOS开发中的小技巧，能大大方便我们的开发，持续更新。\nUITableView的Group样式下顶部空白处理 //分组列表头部空白处理 UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 0.1)]; self.tableView.tableHeaderView = view; UITableView的plain样式下，取消区头停滞效果 - (void)scrollViewDidScroll:(UIScrollView *)scrollView { CGFloat sectionHeaderHeight = sectionHead.height; if (scrollView.contentOffset.y\u0026lt;=sectionHeaderHeight\u0026amp;\u0026amp;scrollView;.contentOffset.y\u0026gt;=0) { scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0); } else if(scrollView.contentOffset.y\u0026gt;=sectionHeaderHeight) { scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0); } } 那个，其实，还是用Group样式吧哈哈。\n获取某个view所在的控制器 - (UIViewController *)viewController { UIViewController *viewController = nil; UIResponder *next = self.nextResponder; while (next) { if ([next isKindOfClass:[UIViewController class]]) { viewController = (UIViewController *)next; break; } next = next.nextResponder; } return viewController; } 两种方法删除NSUserDefaults所有记录 //方法一 NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier]; [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain]; //方法二 - (void)resetDefaults { NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) { [defs removeObjectForKey:key]; } [defs synchronize]; } 打印系统所有已注册的字体名称 #pragma mark - 打印系统所有已注册的字体名称 void enumerateFonts() { for(NSString *familyName in [UIFont familyNames]) { NSLog(@\u0026#34;%@\u0026#34;,familyName); NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName]; for(NSString *fontName in fontNames) { NSLog(@\u0026#34;\\t|- %@\u0026#34;,fontName); } } } 取图片某一像素点的颜色 在UIImage的分类中 - (UIColor *)colorAtPixel:(CGPoint)point { if (!CGRectContainsPoint(CGRectMake(0.0f, 0.0f, self.size.width, self.size.height), point)) { return nil; } CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); int bytesPerPixel = 4; int bytesPerRow = bytesPerPixel * 1; NSUInteger bitsPerComponent = 8; unsigned char pixelData[4] = {0, 0, 0, 0}; CGContextRef context = CGBitmapContextCreate(pixelData, 1, 1, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); CGColorSpaceRelease(colorSpace); CGContextSetBlendMode(context, kCGBlendModeCopy); CGContextTranslateCTM(context, -point.x, point.y - self.size.height); CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, self.size.width, self.size.height), self.CGImage); CGContextRelease(context); CGFloat red = (CGFloat)pixelData[0] / 255.0f; CGFloat green = (CGFloat)pixelData[1] / 255.0f; CGFloat blue = (CGFloat)pixelData[2] / 255.0f; CGFloat alpha = (CGFloat)pixelData[3] / 255.0f; return [UIColor colorWithRed:red green:green blue:blue alpha:alpha]; } 字符串反转 第一种： - (NSString *)reverseWordsInString:(NSString *)str { NSMutableString *newString = [[NSMutableString alloc] initWithCapacity:str.length]; for (NSInteger i = str.length - 1; i \u0026gt;= 0 ; i --) { unichar ch = [str characterAtIndex:i]; [newString appendFormat:@\u0026#34;%c\u0026#34;, ch]; } return newString; } //第二种： - (NSString*)reverseWordsInString:(NSString*)str { NSMutableString *reverString = [NSMutableString stringWithCapacity:str.length]; [str enumerateSubstringsInRange:NSMakeRange(0, str.length) options:NSStringEnumerationReverse | NSStringEnumerationByComposedCharacterSequences usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) { [reverString appendString:substring]; }]; return reverString; } 禁止锁屏， 默认情况下，当设备一段时间没有触控动作时，iOS会锁住屏幕。但有一些应用是不需要锁屏的，比如视频播放器。\n[UIApplication sharedApplication].idleTimerDisabled = YES; 或 [[UIApplication sharedApplication] setIdleTimerDisabled:YES]; 模态推出透明界面 UIViewController *vc = [[UIViewController alloc] init]; UINavigationController *na = [[UINavigationController alloc] initWithRootViewController:vc]; if ([[[UIDevice currentDevice] systemVersion] floatValue] \u0026gt;= 8.0) { na.modalPresentationStyle = UIModalPresentationOverCurrentContext; } else { self.modalPresentationStyle=UIModalPresentationCurrentContext; } [self presentViewController:na animated:YES completion:nil]; Xcode调试不显示内存占用 editSCheme 里面有个选项叫叫做enable zoombie Objects 取消选中 显示隐藏文件 //显示 defaults write com.apple.finder AppleShowAllFiles -bool true killall Finder //隐藏 defaults write com.apple.finder AppleShowAllFiles -bool false killall Finder 字符串按多个符号分割 iOS跳转到App Store下载应用评分 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\u0026#34;itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software\u0026amp;id=APPID\u0026#34;]]; iOS 获取汉字的拼音 + (NSString *)transform:(NSString *)chinese { //将NSString装换成NSMutableString NSMutableString *pinyin = [chinese mutableCopy]; //将汉字转换为拼音(带音标) CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO); NSLog(@\u0026#34;%@\u0026#34;, pinyin); //去掉拼音的音标 CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO); NSLog(@\u0026#34;%@\u0026#34;, pinyin); //返回最近结果 return pinyin; } 手动更改iOS状态栏的颜色 - (void)setStatusBarBackgroundColor:(UIColor *)color { UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@\u0026#34;statusBarWindow\u0026#34;] valueForKey:@\u0026#34;statusBar\u0026#34;]; if ([statusBar respondsToSelector:@selector(setBackgroundColor:)]) { statusBar.backgroundColor = color; } } 判断当前ViewController是push还是present的方式显示的 NSArray *viewcontrollers=self.navigationController.viewControllers; if (viewcontrollers.count \u0026gt; 1) { if ([viewcontrollers objectAtIndex:viewcontrollers.count - 1] == self) { //push方式 [self.navigationController popViewControllerAnimated:YES]; } } else { //present方式 [self dismissViewControllerAnimated:YES completion:nil]; } 获取实际使用的LaunchImage图片 - (NSString *)getLaunchImageName { CGSize viewSize = self.window.bounds.size; // 竖屏 NSString *viewOrientation = @\u0026#34;Portrait\u0026#34;; NSString *launchImageName = nil; NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@\u0026#34;UILaunchImages\u0026#34;]; for (NSDictionary* dict in imagesDict) { CGSize imageSize = CGSizeFromString(dict[@\u0026#34;UILaunchImageSize\u0026#34;]); if (CGSizeEqualToSize(imageSize, viewSize) \u0026amp;\u0026amp; [viewOrientation isEqualToString:dict[@\u0026#34;UILaunchImageOrientation\u0026#34;]]) { launchImageName = dict[@\u0026#34;UILaunchImageName\u0026#34;]; } } return launchImageName; } iOS在当前屏幕获取第一响应 UIWindow * keyWindow = [[UIApplication sharedApplication] keyWindow]; UIView * firstResponder = [keyWindow performSelector:@selector(firstResponder)]; 判断对象是否遵循了某协议 if ([self.selectedController conformsToProtocol:@protocol(RefreshPtotocol)]) { [self.selectedController performSelector:@selector(onTriggerRefresh)]; } 判断view是不是指定视图的子视图 BOOL isView = [textView isDescendantOfView:self.view]; NSArray 快速求总和 最大值 最小值 和 平均值 NSArray *array = [NSArray arrayWithObjects:@\u0026#34;2.0\u0026#34;, @\u0026#34;2.3\u0026#34;, @\u0026#34;3.0\u0026#34;, @\u0026#34;4.0\u0026#34;, @\u0026#34;10\u0026#34;, nil]; CGFloat sum = [[array valueForKeyPath:@\u0026#34;@sum.floatValue\u0026#34;] floatValue]; CGFloat avg = [[array valueForKeyPath:@\u0026#34;@avg.floatValue\u0026#34;] floatValue]; CGFloat max =[[array valueForKeyPath:@\u0026#34;@max.floatValue\u0026#34;] floatValue]; CGFloat min =[[array valueForKeyPath:@\u0026#34;@min.floatValue\u0026#34;] floatValue]; NSLog(@\u0026#34;%f\\n%f\\n%f\\n%f\u0026#34;,sum,avg,max,min); 修改UITextField中Placeholder的文字颜色 [textField setValue:[UIColor redColor] forKeyPath:@\u0026#34;_placeholderLabel.textColor\u0026#34;]; 关于NSDateFormatter的格式 G: 公元时代，例如AD公元 yy: 年的后2位 yyyy: 完整年 MM: 月，显示为1-12 MMM: 月，显示为英文月份简写,如 Jan MMMM: 月，显示为英文月份全称，如 Janualy dd: 日，2位数表示，如02 d: 日，1-2位显示，如 2 EEE: 简写星期几，如Sun EEEE: 全写星期几，如Sunday aa: 上下午，AM/PM H: 时，24小时制，0-23 K：时，12小时制，0-11 m: 分，1-2位 mm: 分，2位 s: 秒，1-2位 ss: 秒，2位 S: 毫秒 获取一个类的所有子类 + (NSArray *) allSubclasses { Class myClass = [self class]; NSMutableArray *mySubclasses = [NSMutableArray array]; unsigned int numOfClasses; Class *classes = objc_copyClassList(\u0026amp;numOfClasses;); for (unsigned int ci = 0; ci \u0026lt; numOfClasses; ci++) { Class superClass = classes[ci]; do{ superClass = class_getSuperclass(superClass); } while (superClass \u0026amp;\u0026amp; superClass != myClass); if (superClass) { [mySubclasses addObject: classes[ci]]; } } free(classes); return mySubclasses; } 监测IOS设备是否设置了代理，需要CFNetwork.framework NSDictionary *proxySettings = (__bridge NSDictionary *)(CFNetworkCopySystemProxySettings()); NSArray *proxies = (__bridge NSArray *)(CFNetworkCopyProxiesForURL((__bridge CFURLRef _Nonnull)([NSURL URLWithString:@\u0026#34;http://www.baidu.com\u0026#34;]), (__bridge CFDictionaryRef _Nonnull)(proxySettings))); NSLog(@\u0026#34;\\n%@\u0026#34;,proxies); NSDictionary *settings = proxies[0]; NSLog(@\u0026#34;%@\u0026#34;,[settings objectForKey:(NSString *)kCFProxyHostNameKey]); NSLog(@\u0026#34;%@\u0026#34;,[settings objectForKey:(NSString *)kCFProxyPortNumberKey]); NSLog(@\u0026#34;%@\u0026#34;,[settings objectForKey:(NSString *)kCFProxyTypeKey]); if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:@\u0026#34;kCFProxyTypeNone\u0026#34;]) { NSLog(@\u0026#34;没代理\u0026#34;); } else { NSLog(@\u0026#34;设置了代理\u0026#34;); } 阿拉伯数字转中文格式 +(NSString *)translation:(NSString *)arebic { NSString *str = arebic; NSArray *arabic_numerals = @[@\u0026#34;1\u0026#34;,@\u0026#34;2\u0026#34;,@\u0026#34;3\u0026#34;,@\u0026#34;4\u0026#34;,@\u0026#34;5\u0026#34;,@\u0026#34;6\u0026#34;,@\u0026#34;7\u0026#34;,@\u0026#34;8\u0026#34;,@\u0026#34;9\u0026#34;,@\u0026#34;0\u0026#34;]; NSArray *chinese_numerals = @[@\u0026#34;一\u0026#34;,@\u0026#34;二\u0026#34;,@\u0026#34;三\u0026#34;,@\u0026#34;四\u0026#34;,@\u0026#34;五\u0026#34;,@\u0026#34;六\u0026#34;,@\u0026#34;七\u0026#34;,@\u0026#34;八\u0026#34;,@\u0026#34;九\u0026#34;,@\u0026#34;零\u0026#34;]; NSArray *digits = @[@\u0026#34;个\u0026#34;,@\u0026#34;十\u0026#34;,@\u0026#34;百\u0026#34;,@\u0026#34;千\u0026#34;,@\u0026#34;万\u0026#34;,@\u0026#34;十\u0026#34;,@\u0026#34;百\u0026#34;,@\u0026#34;千\u0026#34;,@\u0026#34;亿\u0026#34;,@\u0026#34;十\u0026#34;,@\u0026#34;百\u0026#34;,@\u0026#34;千\u0026#34;,@\u0026#34;兆\u0026#34;]; NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chinese_numerals forKeys:arabic_numerals]; NSMutableArray *sums = [NSMutableArray array]; for (int i = 0; i \u0026lt; str.length; i ++) { NSString *substr = [str substringWithRange:NSMakeRange(i, 1)]; NSString *a = [dictionary objectForKey:substr]; NSString *b = digits[str.length -i-1]; NSString *sum = [a stringByAppendingString:b]; if ([a isEqualToString:chinese_numerals[9]]) { if([b isEqualToString:digits[4]] || [b isEqualToString:digits[8]]) { sum = b; if ([[sums lastObject] isEqualToString:chinese_numerals[9]]) { [sums removeLastObject]; } }else { sum = chinese_numerals[9]; } if ([[sums lastObject] isEqualToString:sum]) { continue; } } [sums addObject:sum]; } NSString *sumStr = [sums componentsJoinedByString:@\u0026#34;\u0026#34;]; NSString *chinese = [sumStr substringToIndex:sumStr.length-1]; NSLog(@\u0026#34;%@\u0026#34;,str); NSLog(@\u0026#34;%@\u0026#34;,chinese); return chinese; } Base64编码与NSString对象或NSData对象的转换 // Create NSData object NSData *nsdata = [@\u0026#34;iOS Developer Tips encoded in Base64\u0026#34; dataUsingEncoding:NSUTF8StringEncoding]; // Get NSString from NSData object in Base64 NSString *base64Encoded = [nsdata base64EncodedStringWithOptions:0]; // Print the Base64 encoded string NSLog(@\u0026#34;Encoded: %@\u0026#34;, base64Encoded); // Let\u0026#39;s go the other way... // NSData from the Base64 encoded str NSData *nsdataFromBase64String = [[NSData alloc] initWithBase64EncodedString:base64Encoded options:0]; // Decoded NSString from the NSData NSString *base64Decoded = [[NSString alloc] initWithData:nsdataFromBase64String encoding:NSUTF8StringEncoding]; NSLog(@\u0026#34;Decoded: %@\u0026#34;, base64Decoded); 取消UICollectionView的隐式动画 UICollectionView在reloadItems的时候，默认会附加一个隐式的fade动画，有时候很讨厌，尤其是当你的cell是复合cell的情况下(比如cell使用到了UIStackView)。 下面几种方法都可以帮你去除这些动画\n//方法一 [UIView performWithoutAnimation:^{ [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]]; }]; //方法二 [UIView animateWithDuration:0 animations:^{ [collectionView performBatchUpdates:^{ [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]]; } completion:nil]; }]; //方法三 [UIView setAnimationsEnabled:NO]; [self.trackPanel performBatchUpdates:^{ [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]]; } completion:^(BOOL finished) { [UIView setAnimationsEnabled:YES]; }]; 让Xcode的控制台支持LLDB类型的打印 打开终端输入三条命令: touch ~/.lldbinit echo display @import UIKit \u0026gt;\u0026gt; ~/.lldbinit echo target stop-hook add -o \\\u0026#34;target stop-hook disable\\\u0026#34; \u0026gt;\u0026gt; ~/.lldbinit CocoaPods pod install/pod update更新慢的问题 pod install --verbose --no-repo-update pod update --verbose --no-repo-update 如果不加后面的参数，默认会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少 UIImage 占用内存大小 UIImage *image = [UIImage imageNamed:@\u0026#34;aa\u0026#34;]; NSUInteger size = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage); GCD timer定时器 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue); dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行 dispatch_source_set_event_handler(timer, ^{ //@\u0026#34;倒计时结束，关闭\u0026#34; dispatch_source_cancel(timer); dispatch_async(dispatch_get_main_queue(), ^{ }); }); dispatch_resume(timer); 图片上绘制文字 写一个UIImage的category - (UIImage *)imageWithTitle:(NSString *)title fontSize:(CGFloat)fontSize { //画布大小 CGSize size=CGSizeMake(self.size.width,self.size.height); //创建一个基于位图的上下文 UIGraphicsBeginImageContextWithOptions(size,NO,0.0);//opaque:NO scale:0.0 [self drawAtPoint:CGPointMake(0.0,0.0)]; //文字居中显示在画布上 NSMutableParagraphStyle* paragraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy]; paragraphStyle.lineBreakMode = NSLineBreakByCharWrapping; paragraphStyle.alignment=NSTextAlignmentCenter;//文字居中 //计算文字所占的size,文字居中显示在画布上 CGSize sizeText=[title boundingRectWithSize:self.size options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:fontSize]}context:nil].size; CGFloat width = self.size.width; CGFloat height = self.size.height; CGRect rect = CGRectMake((width-sizeText.width)/2, (height-sizeText.height)/2, sizeText.width, sizeText.height); //绘制文字 [title drawInRect:rect withAttributes:@{ NSFontAttributeName:[UIFont systemFontOfSize:fontSize],NSForegroundColorAttributeName:[ UIColor whiteColor],NSParagraphStyleAttributeName:paragraphStyle}]; //返回绘制的新图形 UIImage *newImage= UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage; } 查找一个视图的所有子视图 - (NSMutableArray *)allSubViewsForView:(UIView *)view { NSMutableArray *array = [NSMutableArray arrayWithCapacity:0]; for (UIView *subView in view.subviews) { [array addObject:subView]; if (subView.subviews.count \u0026gt; 0) { [array addObjectsFromArray:[self allSubViewsForView:subView]]; } } return array; } 计算文件大小 //文件大小 - (long long)fileSizeAtPath:(NSString *)path { NSFileManager *fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:path]) { long long size = [fileManager attributesOfItemAtPath:path error:nil].fileSize; return size; } return 0; } //文件夹大小 - (long long)folderSizeAtPath:(NSString *)path { NSFileManager *fileManager = [NSFileManager defaultManager]; long long folderSize = 0; if ([fileManager fileExistsAtPath:path]) { NSArray *childerFiles = [fileManager subpathsAtPath:path]; for (NSString *fileName in childerFiles) { NSString *fileAbsolutePath = [path stringByAppendingPathComponent:fileName]; if ([fileManager fileExistsAtPath:fileAbsolutePath]) { long long size = [fileManager attributesOfItemAtPath:fileAbsolutePath error:nil].fileSize; folderSize += size; } } } return folderSize; } UIView设置部分圆角 你是不是也遇到过这样的问题，一个button或者label，只要右边的两个角圆角，或者只要一个圆角。该怎么办呢。这就需要图层蒙版来帮助我们了\nCGRect rect = view.bounds; CGSize radio = CGSizeMake(30, 30);//圆角尺寸 UIRectCorner corner = UIRectCornerTopLeft|UIRectCornerTopRight;//这只圆角位置 UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:radio]; CAShapeLayer *masklayer = [[CAShapeLayer alloc]init];//创建shapelayer masklayer.frame = view.bounds; masklayer.path = path.CGPath;//设置路径 view.layer.mask = masklayer; 取上整与取下整 floor(x),有时候也写做Floor(x)，其功能是“下取整”，即取不大于x的最大整数 例如： x=3.14，floor(x)=3 y=9.99999，floor(y)=9 与floor函数对应的是ceil函数，即上取整函数。 ceil函数的作用是求不小于给定实数的最小整数。 ceil(2)=ceil(1.2)=cei(1.5)=2.00 floor函数与ceil函数的返回值均为double型 计算字符串字符长度，一个汉字算两个字符 //方法一： - (int)convertToInt:(NSString*)strtemp { int strlength = 0; char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding]; for (int i=0 ; i\u0026lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding] ;i++) { if (*p) { p++; strlength++; } else { p++; } } return strlength; } //方法二： -(NSUInteger) unicodeLengthOfString: (NSString *) text { NSUInteger asciiLength = 0; for (NSUInteger i = 0; i \u0026lt; text.length; i++) { unichar uc = [text characterAtIndex: i]; asciiLength += isascii(uc) ? 1 : 2; } return asciiLength; } 给UIView设置图片 UIImage *image = [UIImage imageNamed:@\u0026#34;image\u0026#34;]; self.MYView.layer.contents = (__bridge id _Nullable)(image.CGImage); self.MYView.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5); 防止scrollView手势覆盖侧滑手势 [scrollView.panGestureRecognizerrequireGestureRecognizerToFail:self.navigationController.interactivePopGestureRecognizer]; 去掉导航栏返回的back标题 [[UIBarButtonItemappearance]setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)forBarMetrics:UIBarMetricsDefault]; 字符串中是否含有中文 + (BOOL)checkIsChinese:(NSString *)string { for (int i=0; i\u0026lt;string.length; i++) { unichar ch = [string characterAtIndex:i]; if (0x4E00 \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= 0x9FA5) { return YES; } } return NO; } dispatch_group的使用 dispatch_group_t dispatchGroup = dispatch_group_create(); dispatch_group_enter(dispatchGroup); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@\u0026#34;第一个请求完成\u0026#34;); dispatch_group_leave(dispatchGroup); }); dispatch_group_enter(dispatchGroup); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@\u0026#34;第二个请求完成\u0026#34;); dispatch_group_leave(dispatchGroup); }); dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^(){ NSLog(@\u0026#34;请求完成\u0026#34;); }); UITextField每四位加一个空格,实现代理 - (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string { // 四位加一个空格 if ([string isEqualToString:@\u0026#34;\u0026#34;]) { // 删除字符 if ((textField.text.length - 2) % 5 == 0) { textField.text = [textField.text substringToIndex:textField.text.length - 1]; } return YES; } else { if (textField.text.length % 5 == 0) { textField.text = [NSString stringWithFormat:@\u0026#34;%@ \u0026#34;, textField.text]; } } return YES; } 获取私有属性和成员变量 #import \u0026lt;objc/runtime.h\u0026gt; //获取私有属性 比如设置UIDatePicker的字体颜色 - (void)setTextColor { //获取所有的属性，去查看有没有对应的属性 unsigned int count = 0; objc_property_t *propertys = class_copyPropertyList([UIDatePicker class], \u0026amp;count); for(int i = 0;i \u0026lt; count;i ++) { //获得每一个属性 objc_property_t property = propertys[i]; //获得属性对应的nsstring NSString *propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; //输出打印看对应的属性 NSLog(@\u0026#34;propertyname = %@\u0026#34;,propertyName); if ([propertyName isEqualToString:@\u0026#34;textColor\u0026#34;]) { [datePicker setValue:[UIColor whiteColor] forKey:propertyName]; } } } //获得成员变量 比如修改UIAlertAction的按钮字体颜色 unsigned int count = 0; Ivar *ivars = class_copyIvarList([UIAlertAction class], \u0026amp;count); for(int i =0;i \u0026lt; count;i ++) { Ivar ivar = ivars[i]; NSString *ivarName = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding]; NSLog(@\u0026#34;uialertion.ivarName = %@\u0026#34;,ivarName); if ([ivarName isEqualToString:@\u0026#34;_titleTextColor\u0026#34;]) { [alertOk setValue:[UIColor blueColor] forKey:@\u0026#34;titleTextColor\u0026#34;]; [alertCancel setValue:[UIColor purpleColor] forKey:@\u0026#34;titleTextColor\u0026#34;]; } } 获取手机安装的应用 Class c =NSClassFromString(@\u0026#34;LSApplicationWorkspace\u0026#34;); id s = [(id)c performSelector:NSSelectorFromString(@\u0026#34;defaultWorkspace\u0026#34;)]; NSArray *array = [s performSelector:NSSelectorFromString(@\u0026#34;allInstalledApplications\u0026#34;)]; for (id item in array) { NSLog(@\u0026#34;%@\u0026#34;,[item performSelector:NSSelectorFromString(@\u0026#34;applicationIdentifier\u0026#34;)]); //NSLog(@\u0026#34;%@\u0026#34;,[item performSelector:NSSelectorFromString(@\u0026#34;bundleIdentifier\u0026#34;)]); NSLog(@\u0026#34;%@\u0026#34;,[item performSelector:NSSelectorFromString(@\u0026#34;bundleVersion\u0026#34;)]); NSLog(@\u0026#34;%@\u0026#34;,[item performSelector:NSSelectorFromString(@\u0026#34;shortVersionString\u0026#34;)]); } 判断两个日期是否在同一周 写在NSDate的category里面 - (BOOL)isSameDateWithDate:(NSDate *)date { //日期间隔大于七天之间返回NO if (fabs([self timeIntervalSinceDate:date]) \u0026gt;= 7 * 24 *3600) { return NO; } NSCalendar *calender = [NSCalendar currentCalendar]; calender.firstWeekday = 2;//设置每周第一天从周一开始 //计算两个日期分别为这年第几周 NSUInteger countSelf = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:self]; NSUInteger countDate = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:date]; //相等就在同一周，不相等就不在同一周 return countSelf == countDate; } 应用内打开系统设置界面 //iOS8之后 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]]; //如果App没有添加权限，显示的是设定界面。如果App有添加权限（例如通知），显示的是App的设定界面。 //iOS8之前 //先添加一个url type如下图，在代码中调用如下代码,即可跳转到设置页面的对应项 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\u0026#34;prefs:root=WIFI\u0026#34;]]; 可选值如下： About — prefs:root=General\u0026amp;path=About Accessibility — prefs:root=General\u0026amp;path=ACCESSIBILITY Airplane Mode On — prefs:root=AIRPLANE_MODE Auto-Lock — prefs:root=General\u0026amp;path=AUTOLOCK Brightness — prefs:root=Brightness Bluetooth — prefs:root=General\u0026amp;path=Bluetooth Date \u0026amp; Time — prefs:root=General\u0026amp;path=DATE_AND_TIME FaceTime — prefs:root=FACETIME General — prefs:root=General Keyboard — prefs:root=General\u0026amp;path=Keyboard iCloud — prefs:root=CASTLE iCloud Storage \u0026amp; Backup — prefs:root=CASTLE\u0026amp;path=STORAGE_AND_BACKUP International — prefs:root=General\u0026amp;path=INTERNATIONAL Location Services — prefs:root=LOCATION_SERVICES Music — prefs:root=MUSIC Music Equalizer — prefs:root=MUSIC\u0026amp;path=EQ Music Volume Limit — prefs:root=MUSIC\u0026amp;path=VolumeLimit Network — prefs:root=General\u0026amp;path=Network Nike + iPod — prefs:root=NIKE_PLUS_IPOD Notes — prefs:root=NOTES Notification — prefs:root=NOTIFICATI*****_ID Phone — prefs:root=Phone Photos — prefs:root=Photos Profile — prefs:root=General\u0026amp;path=ManagedConfigurationList Reset — prefs:root=General\u0026amp;path=Reset Safari — prefs:root=Safari Siri — prefs:root=General\u0026amp;path=Assistant Sounds — prefs:root=Sounds Software Update — prefs:root=General\u0026amp;path=SOFTWARE_UPDATE_LINK Store — prefs:root=STORE Twitter — prefs:root=TWITTER Usage — prefs:root=General\u0026amp;path=USAGE VPN — prefs:root=General\u0026amp;path=Network/VPN Wallpaper — prefs:root=Wallpaper Wi-Fi — prefs:root=WIFI 屏蔽触发事件，2秒后取消屏蔽 [[UIApplication sharedApplication] beginIgnoringInteractionEvents]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [[UIApplication sharedApplication] endIgnoringInteractionEvents] }); 动画暂停再开始 -(void)pauseLayer:(CALayer *)layer { CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil]; layer.speed = 0.0; layer.timeOffset = pausedTime; } -(void)resumeLayer:(CALayer *)layer { CFTimeInterval pausedTime = [layer timeOffset]; layer.speed = 1.0; layer.timeOffset = 0.0; layer.beginTime = 0.0; CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime; layer.beginTime = timeSincePause; } fillRule原理 iOS中数字的格式化 //通过NSNumberFormatter，同样可以设置NSNumber输出的格式。例如如下代码： NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init]; formatter.numberStyle = NSNumberFormatterDecimalStyle; NSString *string = [formatter stringFromNumber:[NSNumber numberWithInt:123456789]]; NSLog(@\u0026#34;Formatted number string:%@\u0026#34;,string); //输出结果为：[1223:403] Formatted number string:123,456,789 //其中NSNumberFormatter类有个属性numberStyle，它是一个枚举型，设置不同的值可以输出不同的数字格式。该枚举包括： typedef NS_ENUM(NSUInteger, NSNumberFormatterStyle) { NSNumberFormatterNoStyle = kCFNumberFormatterNoStyle, NSNumberFormatterDecimalStyle = kCFNumberFormatterDecimalStyle, NSNumberFormatterCurrencyStyle = kCFNumberFormatterCurrencyStyle, NSNumberFormatterPercentStyle = kCFNumberFormatterPercentStyle, NSNumberFormatterScientificStyle = kCFNumberFormatterScientificStyle, NSNumberFormatterSpellOutStyle = kCFNumberFormatterSpellOutStyle }; //各个枚举对应输出数字格式的效果如下：其中第三项和最后一项的输出会根据系统设置的语言区域的不同而不同。 [1243:403] Formatted number string:123456789 [1243:403] Formatted number string:123,456,789 [1243:403] Formatted number string:￥123,456,789.00 [1243:403] Formatted number string:-539,222,988% [1243:403] Formatted number string:1.23456789E8 [1243:403] Formatted number string:一亿二千三百四十五万六千七百八十九 如何获取WebView所有的图片地址， 在网页加载完成时，通过js获取图片和添加点击的识别方式\n//UIWebView - (void)webViewDidFinishLoad:(UIWebView *)webView { //这里是js，主要目的实现对url的获取 static NSString * const jsGetImages = @\u0026#34;function getImages(){\\ var objs = document.getElementsByTagName(\\\u0026#34;img\\\u0026#34;);\\ var imgScr = \u0026#39;\u0026#39;;\\ for(var i=0;i\u0026lt;objs.length;i++){\\ imgScr = imgScr + objs[i].src + \u0026#39;+\u0026#39;;\\ };\\ return imgScr;\\ };\u0026#34;; [webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法 NSString *urlResult = [webView stringByEvaluatingJavaScriptFromString:@\u0026#34;getImages()\u0026#34;]; NSArray *urlArray = [NSMutableArray arrayWithArray:[urlResult componentsSeparatedByString:@\u0026#34;+\u0026#34;]]; //urlResurlt 就是获取到得所有图片的url的拼接；mUrlArray就是所有Url的数组 } //WKWebView - (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation { static NSString * const jsGetImages = @\u0026#34;function getImages(){\\ var objs = document.getElementsByTagName(\\\u0026#34;img\\\u0026#34;);\\ var imgScr = \u0026#39;\u0026#39;;\\ for(var i=0;i\u0026lt;objs.length;i++){\\ imgScr = imgScr + objs[i].src + \u0026#39;+\u0026#39;;\\ };\\ return imgScr;\\ };\u0026#34;; [webView evaluateJavaScript:jsGetImages completionHandler:nil]; [webView evaluateJavaScript:@\u0026#34;getImages()\u0026#34; completionHandler:^(id _Nullable result, NSError * _Nullable error) { NSLog(@\u0026#34;%@\u0026#34;,result); }]; } 获取到webview的高度 CGFloat height = [[self.webView stringByEvaluatingJavaScriptFromString:@\u0026#34;document.body.offsetHeight\u0026#34;] floatValue]; navigationBar变为纯透明 //第一种方法 //导航栏纯透明 [self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; //去掉导航栏底部的黑线 self.navigationBar.shadowImage = [UIImage new]; //第二种方法 [[self.navigationBar subviews] objectAtIndex:0].alpha = 0; tabBar同理 [self.tabBar setBackgroundImage:[UIImage new]]; self.tabBar.shadowImage = [UIImage new]; navigationBar根据滑动距离的渐变色实现 //第一种 - (void)scrollViewDidScroll:(UIScrollView *)scrollView { CGFloat offsetToShow = 200.0;//滑动多少就完全显示 CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow; [[self.navigationController.navigationBar subviews] objectAtIndex:0].alpha = alpha; } //第二种 - (void)scrollViewDidScroll:(UIScrollView *)scrollView { CGFloat offsetToShow = 200.0; CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow; [self.navigationController.navigationBar setShadowImage:[UIImage new]]; [self.navigationController.navigationBar setBackgroundImage:[self imageWithColor:[[UIColor orangeColor]colorWithAlphaComponent:alpha]] forBarMetrics:UIBarMetricsDefault]; } //生成一张纯色的图片 - (UIImage *)imageWithColor:(UIColor *)color { CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return theImage; } iOS 开发中一些相关的路径 模拟器的位置: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 文档安装位置: /Applications/Xcode.app/Contents/Developer/Documentation/DocSets 插件保存路径: ~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins 自定义代码段的保存路径: ~/Library/Developer/Xcode/UserData/CodeSnippets/ 如果找不到CodeSnippets文件夹，可以自己新建一个CodeSnippets文件夹。 描述文件路径 ~/Library/MobileDevice/Provisioning Profiles navigationItem的BarButtonItem如何紧靠屏幕右边界或者左边界？ 一般情况下，右边的item会和屏幕右侧保持一段距离： 下面是通过添加一个负值宽度的固定间距的item来解决，也可以改变宽度实现不同的间隔：\nUIImage *img = [[UIImage imageNamed:@\u0026#34;icon_cog\u0026#34;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; //宽度为负数的固定间距的系统item UIBarButtonItem *rightNegativeSpacer = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; [rightNegativeSpacer setWidth:-15]; UIBarButtonItem *rightBtnItem1 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)]; UIBarButtonItem *rightBtnItem2 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)]; self.navigationItem.rightBarButtonItems = @[rightNegativeSpacer,rightBtnItem1,rightBtnItem2]; NSString进行URL编码和解码 NSString *string = @\u0026#34;http://abc.com?aaa=你好\u0026amp;bbb=tttee\u0026#34;; //编码 打印：http://abc.com?aaa=%E4%BD%A0%E5%A5%BD\u0026amp;bbb=tttee string = [string stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]; //解码 打印：http://abc.com?aaa=你好\u0026amp;bbb=tttee string = [string stringByRemovingPercentEncoding]; UIWebView设置User-Agent。 //设置 NSDictionary *dic = @{@\u0026#34;UserAgent\u0026#34;:@\u0026#34;your UserAgent\u0026#34;}; [[NSUserDefaults standardUserDefaults] registerDefaults:dic]; //获取 NSString *agent = [self.WebView stringByEvaluatingJavaScriptFromString:@\u0026#34;navigator.userAgent\u0026#34;]; 获取硬盘总容量与可用容量: NSFileManager *fileManager = [NSFileManager defaultManager]; NSDictionary *attributes = [fileManager attributesOfFileSystemForPath:NSHomeDirectory() error:nil]; NSLog(@\u0026#34;容量%.2fG\u0026#34;,[attributes[NSFileSystemSize] doubleValue] / (powf(1024, 3))); NSLog(@\u0026#34;可用%.2fG\u0026#34;,[attributes[NSFileSystemFreeSize] doubleValue] / powf(1024, 3)); 获取UIColor的RGBA值 UIColor *color = [UIColor colorWithRed:0.2 green:0.3 blue:0.9 alpha:1.0]; const CGFloat *components = CGColorGetComponents(color.CGColor); NSLog(@\u0026#34;Red: %.1f\u0026#34;, components[0]); NSLog(@\u0026#34;Green: %.1f\u0026#34;, components[1]); NSLog(@\u0026#34;Blue: %.1f\u0026#34;, components[2]); NSLog(@\u0026#34;Alpha: %.1f\u0026#34;, components[3]); 修改textField的placeholder的字体颜色、大小 [self.textField setValue:[UIColor redColor] forKeyPath:@\u0026#34;_placeholderLabel.textColor\u0026#34;]; [self.textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@\u0026#34;_placeholderLabel.font\u0026#34;]; AFN移除JSON中的NSNull AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer]; response.removesKeysWithNullValues = YES; ceil()和floor() ceil()功 能：返回大于或者等于指定表达式的最小整数 floor()功 能：返回小于或者等于指定表达式的最大整数\nUIWebView里面的图片自适应屏幕 在webView加载完的代理方法里面这样写：\n- (void)webViewDidFinishLoad:(UIWebView *)webView { NSString *js = @\u0026#34;function imgAutoFit() { \\ var imgs = document.getElementsByTagName(\u0026#39;img\u0026#39;); \\ for (var i = 0; i \u0026lt; imgs.length; ++i) { \\ var img = imgs[i]; \\ img.style.maxWidth = %f; \\ } \\ }\u0026#34;; js = [NSString stringWithFormat:js, [UIScreen mainScreen].bounds.size.width - 20]; [webView stringByEvaluatingJavaScriptFromString:js]; [webView stringByEvaluatingJavaScriptFromString:@\u0026#34;imgAutoFit()\u0026#34;]; } UILabel显示Html NSString *htmlString = @\u0026#34;Some html string\u0026#34;; NSAttributedString *attrStr = [[NSAttributedString alloc] initWithData:[htmlString dataUsingEncoding:NSUnicodeStringEncoding] options:@{NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType} documentAttributes:nil error:nil]; UILabel *label = [[UILabel alloc] initWithFrame:self.view.bounds]; label.attributedText = attrStr; [self.view addSubview:label]; 模拟器语言切换 xode\u0026mdash;\u0026gt;Product\u0026mdash;\u0026gt;Scheme\u0026mdash;\u0026gt;Edit Scheme\u0026mdash;\u0026gt;Run\u0026mdash;\u0026gt;Application Language\u0026amp;Region 在这里选择所需要的语言，这样再运行的时候，模拟器语言就变成了所选的。 汉字转拼音 NSString *chineseText = @\u0026#34;啦啦啦德玛西亚\u0026#34;; if (chineseText.length \u0026gt; 0) { NSMutableString *ms = [[NSMutableString alloc] initWithString:chineseText]; //带声标 if (CFStringTransform((__bridge CFMutableStringRef)ms, 0, kCFStringTransformMandarinLatin, NO)) { NSLog(@\u0026#34;pinyin: %@\u0026#34;, ms); } //不带声标 if (CFStringTransform((__bridge CFMutableStringRef)ms, 0, kCFStringTransformStripDiacritics, NO)) { NSLog(@\u0026#34;pinyin: %@\u0026#34;, ms); } NSString *name = [NSString stringWithString:ms]; NSLog(@\u0026#34;%@\u0026#34;,name); } 使用UIInterpolatingMotionEffect可以使页面随着设备在空间的移动而发生微移。具体的效果可以查看IOS7系统的解锁界面 UIInterpolatingMotionEffect *interpolationHorizontal = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@\u0026#34;center.x\u0026#34; type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis]; interpolationHorizontal.minimumRelativeValue = @(-20); interpolationHorizontal.maximumRelativeValue = @(20); UIInterpolatingMotionEffect *interpolationVertical = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@\u0026#34;center.y\u0026#34; type:UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis]; interpolationVertical.minimumRelativeValue = @(-20); interpolationVertical.maximumRelativeValue = @(20); [self.view addMotionEffect:interpolationHorizontal]; [self.view addMotionEffect:interpolationVertical]; NS_REQUIRES_SUPER 要求子类重写父类的方法必须先调用super，子类重写这个方法就会自动警告提示要调用这个super方法。\n- (void)prepare NS_REQUIRES_SUPER; WebView长按保存图片 加一个长按手势，在响应里： NSString *imgURL = [NSString stringWithFormat:@\u0026#34;document.elementFromPoint(%f, %f).src\u0026#34;, touchPoint.x, touchPoint.y]; NSString *urlToSave = [self.webView stringByEvaluatingJavaScriptFromString:imgURL]; 文字转语音播放 #import \u0026lt;AVFoundation/AVFoundation.h\u0026gt; @property (nonatomic, strong) AVSpeechSynthesizer *av; //开始或暂停 - (void)start:(UIButton *)sender { if (sender.selected) { if (self.av.isPaused) { [self.av continueSpeaking]; sender.selected = !sender.selected; } else { AVSpeechUtterance*utterance = [[AVSpeechUtterance alloc]initWithString:@\u0026#34;大渣好 我系渣渣辉\u0026#34;]; utterance.rate=0.5;// 设置语速，范围0-1，注意0最慢，1最快；AVSpeechUtteranceMinimumSpeechRate最慢，AVSpeechUtteranceMaximumSpeechRate最快 utterance.voice = [AVSpeechSynthesisVoice voiceWithLanguage:@\u0026#34;en-GB\u0026#34;];//设置发音，这是中文普通话; self.av = [[AVSpeechSynthesizer alloc] init]; self.av.delegate = self; [self.av speakUtterance:utterance]; sender.selected = !sender.selected; } } else { //[av stopSpeakingAtBoundary:AVSpeechBoundaryWord];//感觉效果一样，对应代理\u0026gt;\u0026gt;\u0026gt;取消 [self.av pauseSpeakingAtBoundary:AVSpeechBoundaryWord];//暂停 sender.selected = !sender.selected; } } @protocol AVSpeechSynthesizerDelegate \u0026lt;NSObject\u0026gt; @optional - (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer didStartSpeechUtterance:(AVSpeechUtterance *)utterance; - (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer didFinishSpeechUtterance:(AVSpeechUtterance *)utterance; - (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer didPauseSpeechUtterance:(AVSpeechUtterance *)utterance; - (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer didContinueSpeechUtterance:(AVSpeechUtterance *)utterance; - (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer didCancelSpeechUtterance:(AVSpeechUtterance *)utterance; - (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer willSpeakRangeOfSpeechString:(NSRange)characterRange utterance:(AVSpeechUtterance *)utterance; @end 在Dock上添加空白区格 终端运行两条命令： defaults write com.apple.dock persistent-apps -array-add \u0026#39;{\u0026#34;tile-type\u0026#34;=\u0026#34;spacer-tile\u0026#34;;}\u0026#39; killall Dock 改变截屏文件的类型 默认的，MacOS把截屏存成PNG格式，通常这都没什么问题。但是如果你想要其他的格式，例如jpg？则使用以下命令：\ndefaults write com.apple.screencapture type jpg 只需要把jpg替换成你想要的扩展格式，无论是JPEG，TIFF或者是PDF，然后键入如下命令：\nkillall SystemUIServer 将数字转成字节单位 NSString *folderSizeStr = [NSByteCountFormatter stringFromByteCount:12334 countStyle:NSByteCountFormatterCountStyleBinary]; NSLog(@\u0026#34;%@\u0026#34;,folderSizeStr); 检查有没有使用idfa 终端运行: grep -r advertisingIdentifier . 查看app启动耗时 在 Xcode 中 Edit scheme -\u0026gt; Run -\u0026gt; Auguments 添加环境变量DYLD_PRINT_STATISTICS 设为 1。启动app控制台输出的内容如下： 获取图片类型 - (NSString *)contentTypeForImageData:(NSData *)data { uint8_t c; [data getBytes:\u0026amp;c length:1]; switch (c) { case 0xFF: return @\u0026#34;jpeg\u0026#34;; case 0x89: return @\u0026#34;png\u0026#34;; case 0x47: return @\u0026#34;gif\u0026#34;; case 0x49: case 0x4D: return @\u0026#34;tiff\u0026#34;; case 0x52: if ([data length] \u0026lt; 12) { return nil; } NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding]; if ([testString hasPrefix:@\u0026#34;RIFF\u0026#34;] \u0026amp;\u0026amp; [testString hasSuffix:@\u0026#34;WEBP\u0026#34;]) { return @\u0026#34;webp\u0026#34;; } return nil; } return nil; } 持续更新中……。\n","date":"2016-08-23T17:37:54Z","permalink":"https://lisongrc.github.io/p/20160814f9ac89/","title":"iOS小技巧总结，绝对有你想要的"},{"content":"大家都是知道使用宏不仅方便，而且可以提高开发效率。下面总结了iOS开发过程中的一些常用宏，会持续的往里面添加。\n//字符串是否为空 #define kStringIsEmpty(str) ([str isKindOfClass:[NSNull class]] || str == nil || [str length] \u0026lt; 1 ? YES : NO ) //数组是否为空 #define kArrayIsEmpty(array) (array == nil || [array isKindOfClass:[NSNull class]] || array.count == 0) //字典是否为空 #define kDictIsEmpty(dic) (dic == nil || [dic isKindOfClass:[NSNull class]] || dic.allKeys == 0) //是否是空对象 #define kObjectIsEmpty(_object) (_object == nil \\ || [_object isKindOfClass:[NSNull class]] \\ || ([_object respondsToSelector:@selector(length)] \u0026amp;\u0026amp; [(NSData *)_object length] == 0) \\ || ([_object respondsToSelector:@selector(count)] \u0026amp;\u0026amp; [(NSArray *)_object count] == 0)) //获取屏幕宽度与高度 #define kScreenWidth \\ ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? [UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale : [UIScreen mainScreen].bounds.size.width) #define kScreenHeight \\ ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? [UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale : [UIScreen mainScreen].bounds.size.height) #define kScreenSize \\ ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? CGSizeMake([UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale,[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale) : [UIScreen mainScreen].bounds.size) //一些缩写 #define kApplication [UIApplication sharedApplication] #define kKeyWindow [UIApplication sharedApplication].keyWindow #define kAppDelegate [UIApplication sharedApplication].delegate #define kUserDefaults [NSUserDefaults standardUserDefaults] #define kNotificationCenter [NSNotificationCenter defaultCenter] //APP版本号 #define kAppVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@\u0026#34;CFBundleShortVersionString\u0026#34;] //系统版本号 #define kSystemVersion [[UIDevice currentDevice] systemVersion] //获取当前语言 #define kCurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0]) //判断是否为iPhone #define kISiPhone (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone) //判断是否为iPad #define kISiPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) //获取沙盒Document路径 #define kDocumentPath [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject] //获取沙盒temp路径 #define kTempPath NSTemporaryDirectory() //获取沙盒Cache路径 #define kCachePath [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject] //判断是真机还是模拟器 #if TARGET_OS_IPHONE //真机 #endif #if TARGET_IPHONE_SIMULATOR //模拟器 #endif //开发的时候打印，但是发布的时候不打印的NSLog #ifdef DEBUG #define NSLog(...) NSLog(@\u0026#34;%s 第%d行 \\n %@\\n\\n\u0026#34;,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__]) #else #define NSLog(...) #endif //颜色 #define kRGBColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0] #define kRGBAColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(r)/255.0 blue:(r)/255.0 alpha:a] #define kRandomColor kRGBColor(arc4random_uniform(256),arc4random_uniform(256),arc4random_uniform(256)) #define kColorWithHex(rgbValue) \\ [UIColor colorWithRed:((float)((rgbValue \u0026amp; 0xFF0000) \u0026gt;\u0026gt; 16)) / 255.0 \\ green:((float)((rgbValue \u0026amp; 0xFF00) \u0026gt;\u0026gt; 8)) / 255.0 \\ blue:((float)(rgbValue \u0026amp; 0xFF)) / 255.0 alpha:1.0] //弱引用/强引用 #define kWeakSelf(type) __weak typeof(type) weak##type = type; #define kStrongSelf(type) __strong typeof(type) type = weak##type; //由角度转换弧度 #define kDegreesToRadian(x) (M_PI * (x) / 180.0) //由弧度转换角度 #define kRadianToDegrees(radian) (radian * 180.0) / (M_PI) //获取一段时间间隔 #define kStartTime CFAbsoluteTime start = CFAbsoluteTimeGetCurrent(); #define kEndTime NSLog(@\u0026#34;Time: %f\u0026#34;, CFAbsoluteTimeGetCurrent() - start) 持续更新中……。\n","date":"2016-08-18T16:22:23Z","permalink":"https://lisongrc.github.io/p/201608c4f2d814/","title":"iOS开发常用宏，持续更新中"}]